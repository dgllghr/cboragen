const std = @import("std");
const parser = @import("parser");
const Ast = parser.Ast;
const topo = @import("topo.zig");
const config = @import("config.zig");

const FsGen = @This();

writer: std.io.AnyWriter,
schema: Ast.Schema,
arena: std.mem.Allocator,
namespace: []const u8,
varint_as_number: bool,
loop_depth: u32,

/// Names of types in the current recursive codec group (null when not in one).
rec_group: ?[]const []const u8,

/// Namespace → Schema for imported schemas.
imports: std.StringHashMap(Ast.Schema),

/// Custom type mappings from config file.
type_mappings: std.StringHashMap(config.TypeMapping),

/// Inline types discovered during pass 1, keyed by pointer identity.
inline_struct_names: std.AutoHashMap(*const Ast.StructDef, []const u8),
inline_enum_names: std.AutoHashMap(*const Ast.EnumDef, []const u8),
inline_union_names: std.AutoHashMap(*const Ast.UnionDef, []const u8),

/// Ordered list of inline types to emit (preserves discovery order).
inline_structs: std.ArrayList(InlineStruct),
inline_enums: std.ArrayList(InlineEnum),
inline_unions: std.ArrayList(InlineUnion),

const InlineStruct = struct { name: []const u8, def: *const Ast.StructDef };
const InlineEnum = struct { name: []const u8, def: *const Ast.EnumDef };
const InlineUnion = struct { name: []const u8, def: *const Ast.UnionDef };

pub const Options = struct {
    varint_as_number: bool = false,
    namespace: []const u8,
    type_mappings: std.StringHashMap(config.TypeMapping),
};

pub fn init(
    writer: std.io.AnyWriter,
    schema: Ast.Schema,
    imports: std.StringHashMap(Ast.Schema),
    arena: std.mem.Allocator,
    options: Options,
) FsGen {
    return .{
        .writer = writer,
        .schema = schema,
        .arena = arena,
        .namespace = options.namespace,
        .varint_as_number = options.varint_as_number,
        .loop_depth = 0,
        .rec_group = null,
        .imports = imports,
        .type_mappings = options.type_mappings,
        .inline_struct_names = std.AutoHashMap(*const Ast.StructDef, []const u8).init(arena),
        .inline_enum_names = std.AutoHashMap(*const Ast.EnumDef, []const u8).init(arena),
        .inline_union_names = std.AutoHashMap(*const Ast.UnionDef, []const u8).init(arena),
        .inline_structs = .{},
        .inline_enums = .{},
        .inline_unions = .{},
    };
}

const Error = std.io.AnyWriter.Error || std.mem.Allocator.Error;

pub fn generate(self: *FsGen) Error!void {
    // Pass 1: collect inline types — imported schemas first, then main
    var import_it = self.imports.iterator();
    while (import_it.next()) |entry| {
        for (entry.value_ptr.definitions) |def| {
            try self.collectInlineTypes(def.name, def.ty);
        }
    }
    for (self.schema.definitions) |def| {
        try self.collectInlineTypes(def.name, def.ty);
    }

    // Build all_types for topological sort
    var all_types_list: std.ArrayList(topo.TypeInfo) = .{};

    // Add inline types
    for (self.inline_structs.items) |entry| {
        try all_types_list.append(self.arena, .{
            .name = entry.name,
            .def = .{ .doc = null, .name = entry.name, .ty = .{ .struct_ = entry.def }, .span = entry.def.span, .name_span = entry.def.span },
        });
    }
    for (self.inline_enums.items) |entry| {
        try all_types_list.append(self.arena, .{
            .name = entry.name,
            .def = .{ .doc = null, .name = entry.name, .ty = .{ .enum_ = entry.def }, .span = entry.def.span, .name_span = entry.def.span },
        });
    }
    for (self.inline_unions.items) |entry| {
        try all_types_list.append(self.arena, .{
            .name = entry.name,
            .def = .{ .doc = null, .name = entry.name, .ty = .{ .union_ = entry.def }, .span = entry.def.span, .name_span = entry.def.span },
        });
    }

    // Add imported top-level types
    var import_it2 = self.imports.iterator();
    while (import_it2.next()) |entry| {
        for (entry.value_ptr.definitions) |def| {
            try all_types_list.append(self.arena, .{ .name = def.name, .def = def });
        }
    }
    // Add main schema top-level types
    for (self.schema.definitions) |def| {
        try all_types_list.append(self.arena, .{ .name = def.name, .def = def });
    }

    const groups = try topo.sort(self.arena, all_types_list.items);

    // Build name → TypeDef map for looking up defs
    var type_map = std.StringHashMap(Ast.TypeDef).init(self.arena);
    for (all_types_list.items) |ti| {
        try type_map.put(ti.name, ti.def);
    }

    // Emit header
    try self.writer.print("// Generated by cboragen — do not edit\nnamespace {s}\n\nopen System\n\n", .{self.namespace});

    // Import runtime
    try self.writer.writeAll("open Cboragen\n\n");

    // === Types ===
    try self.writer.writeAll("// === Types ===\n\n");
    for (groups) |group| {
        if (group.names.len == 1) {
            const name = group.names[0];
            if (self.type_mappings.contains(name)) continue;
            const def = type_map.get(name) orelse continue;
            try self.emitTypeDef(name, def, null);
        } else {
            // Mutually recursive group — use `and`
            for (group.names, 0..) |name, i| {
                if (self.type_mappings.contains(name)) continue;
                const def = type_map.get(name) orelse continue;
                if (i == 0) {
                    try self.emitTypeDef(name, def, null);
                } else {
                    try self.emitTypeDef(name, def, "and");
                }
            }
        }
    }

    // === Codecs ===
    try self.writer.writeAll("\n// === Codecs ===\n");
    for (groups) |group| {
        if (group.is_recursive and group.names.len > 1) {
            try self.emitRecursiveCodecGroup(group, &type_map);
        } else {
            for (group.names) |name| {
                if (self.type_mappings.contains(name)) continue;
                const def = type_map.get(name) orelse continue;
                try self.emitCodecModule(name, def, null);
            }
        }
    }
}

// =========================================================================
// Pass 1: Collect inline types
// =========================================================================

fn collectInlineTypes(self: *FsGen, parent_name: []const u8, ty: Ast.TypeExpr) Error!void {
    switch (ty) {
        .struct_ => |s| {
            for (s.fields) |field| {
                try self.collectInlineTypesField(parent_name, field);
            }
        },
        .enum_ => {},
        .union_ => |u| {
            for (u.variants) |v| {
                if (v.payload) |payload| {
                    try self.collectInlineTypesVariant(parent_name, v.name, payload);
                }
            }
        },
        .array => |a| {
            try self.collectInlineTypes(parent_name, a.getElement());
        },
        .option => |o| {
            try self.collectInlineTypes(parent_name, o.child);
        },
        else => {},
    }
}

fn collectInlineTypesField(self: *FsGen, parent_name: []const u8, field: Ast.FieldDef) Error!void {
    switch (field.ty) {
        .struct_ => |s| {
            const fname = try self.sanitizeFieldName(field.name);
            const name = try std.fmt.allocPrint(self.arena, "{s}_{s}", .{ parent_name, fname });
            try self.inline_struct_names.put(s, name);
            try self.inline_structs.append(self.arena, .{ .name = name, .def = s });
            for (s.fields) |f| {
                try self.collectInlineTypesField(name, f);
            }
        },
        .enum_ => |e| {
            const fname = try self.sanitizeFieldName(field.name);
            const name = try std.fmt.allocPrint(self.arena, "{s}_{s}", .{ parent_name, fname });
            try self.inline_enum_names.put(e, name);
            try self.inline_enums.append(self.arena, .{ .name = name, .def = e });
        },
        .union_ => |u| {
            const fname = try self.sanitizeFieldName(field.name);
            const name = try std.fmt.allocPrint(self.arena, "{s}_{s}", .{ parent_name, fname });
            try self.inline_union_names.put(u, name);
            try self.inline_unions.append(self.arena, .{ .name = name, .def = u });
            for (u.variants) |v| {
                if (v.payload) |payload| {
                    try self.collectInlineTypesVariant(name, v.name, payload);
                }
            }
        },
        .array => |a| {
            try self.collectInlineTypes(parent_name, a.getElement());
        },
        .option => |o| {
            try self.collectInlineTypes(parent_name, o.child);
        },
        else => {},
    }
}

fn collectInlineTypesVariant(self: *FsGen, parent_name: []const u8, variant_name: []const u8, payload: Ast.TypeExpr) Error!void {
    switch (payload) {
        .struct_ => |s| {
            const name = try std.fmt.allocPrint(self.arena, "{s}_{s}", .{ parent_name, variant_name });
            try self.inline_struct_names.put(s, name);
            try self.inline_structs.append(self.arena, .{ .name = name, .def = s });
            for (s.fields) |f| {
                try self.collectInlineTypesField(name, f);
            }
        },
        .enum_ => |e| {
            const name = try std.fmt.allocPrint(self.arena, "{s}_{s}", .{ parent_name, variant_name });
            try self.inline_enum_names.put(e, name);
            try self.inline_enums.append(self.arena, .{ .name = name, .def = e });
        },
        .union_ => |u| {
            const name = try std.fmt.allocPrint(self.arena, "{s}_{s}", .{ parent_name, variant_name });
            try self.inline_union_names.put(u, name);
            try self.inline_unions.append(self.arena, .{ .name = name, .def = u });
            for (u.variants) |v| {
                if (v.payload) |p| {
                    try self.collectInlineTypesVariant(name, v.name, p);
                }
            }
        },
        .array => |a| {
            try self.collectInlineTypes(parent_name, a.getElement());
        },
        .option => |o| {
            try self.collectInlineTypes(parent_name, o.child);
        },
        else => {},
    }
}

// =========================================================================
// Type emission
// =========================================================================

/// Emit a type definition. `keyword_override` is "and" for mutually recursive types.
fn emitTypeDef(self: *FsGen, name: []const u8, def: Ast.TypeDef, keyword_override: ?[]const u8) Error!void {
    try self.emitDoc(def.doc);
    switch (def.ty) {
        .struct_ => |s| try self.emitStructType(name, s, keyword_override),
        .enum_ => |e| try self.emitEnumType(name, e, keyword_override),
        .union_ => |u| try self.emitUnionType(name, u, keyword_override),
        else => {
            // Type alias
            const kw = keyword_override orelse "type";
            try self.writer.print("{s} {s} = ", .{ kw, name });
            try self.emitTypeRef(def.ty);
            try self.writer.writeAll("\n\n");
        },
    }
}

fn emitStructType(self: *FsGen, name: []const u8, def: *const Ast.StructDef, keyword_override: ?[]const u8) Error!void {
    if (keyword_override) |kw| {
        try self.writer.print("{s} [<Struct>] {s} =\n", .{ kw, name });
    } else {
        try self.writer.print("[<Struct>]\ntype {s} =\n", .{name});
    }
    if (def.fields.len == 0) {
        try self.writer.writeAll("    { _empty: byte }\n\n");
    } else {
        try self.writer.writeAll("    { ");
        for (def.fields, 0..) |field, i| {
            if (i > 0) try self.writer.writeAll("      ");
            const fname = try self.toPascalCase(field.name);
            try self.writer.print("{s}: ", .{fname});
            try self.emitTypeRef(field.ty);
            if (i < def.fields.len - 1) {
                try self.writer.writeAll("\n");
            }
        }
        try self.writer.writeAll(" }\n\n");
    }
}

fn emitEnumType(self: *FsGen, name: []const u8, def: *const Ast.EnumDef, keyword_override: ?[]const u8) Error!void {
    const kw = keyword_override orelse "type";
    try self.writer.print("{s} {s} =\n", .{ kw, name });
    for (def.variants) |v| {
        try self.writer.print("    | {s} = {d}\n", .{ v.name, v.tag });
    }
    try self.writer.writeAll("\n");
}

fn emitUnionType(self: *FsGen, name: []const u8, def: *const Ast.UnionDef, keyword_override: ?[]const u8) Error!void {
    if (keyword_override) |kw| {
        try self.writer.print("{s} [<Struct; RequireQualifiedAccess>] {s} =\n", .{ kw, name });
    } else {
        try self.writer.print("[<Struct; RequireQualifiedAccess>]\ntype {s} =\n", .{name});
    }
    for (def.variants) |v| {
        const vname = try self.toPascalCase(v.name);
        if (v.payload) |payload| {
            const field_name = try self.toLowerCamelCase(v.name);
            try self.writer.print("    | {s} of {s}Value: ", .{ vname, field_name });
            try self.emitTypeRef(payload);
            try self.writer.writeAll("\n");
        } else {
            try self.writer.print("    | {s}\n", .{vname});
        }
    }
    try self.writer.writeAll("\n");
}

fn emitTypeRef(self: *FsGen, ty: Ast.TypeExpr) Error!void {
    switch (ty) {
        .bool => try self.writer.writeAll("bool"),
        .string => try self.writer.writeAll("string"),
        .int => |i| {
            const name = switch (i.kind) {
                .u8 => "byte",
                .u16 => "uint16",
                .u32 => "uint32",
                .u64 => "uint64",
                .i8 => "sbyte",
                .i16 => "int16",
                .i32 => "int",
                .i64 => "int64",
                .uvar => if (self.varint_as_number) "int" else "uint64",
                .ivar => if (self.varint_as_number) "int" else "int64",
            };
            try self.writer.writeAll(name);
        },
        .float => |f| {
            const name = switch (f.kind) {
                .f16 => "Half",
                .f32 => "float32",
                .f64 => "float",
            };
            try self.writer.writeAll(name);
        },
        .struct_ => |s| {
            if (self.inline_struct_names.get(s)) |name| {
                try self.writer.writeAll(name);
            } else {
                try self.writer.writeAll("obj (* inline struct *)");
            }
        },
        .enum_ => |e| {
            if (self.inline_enum_names.get(e)) |name| {
                try self.writer.writeAll(name);
            } else {
                try self.writer.writeAll("int (* inline enum *)");
            }
        },
        .union_ => |u| {
            if (self.inline_union_names.get(u)) |name| {
                try self.writer.writeAll(name);
            } else {
                try self.writer.writeAll("obj (* inline union *)");
            }
        },
        .option => |o| {
            try self.emitTypeRef(o.child);
            try self.writer.writeAll(" voption");
        },
        .array => |a| {
            if (isU8Array(a.getElement())) {
                try self.writer.writeAll("byte array");
            } else {
                try self.emitTypeRef(a.getElement());
                try self.writer.writeAll(" array");
            }
        },
        .named => |n| {
            if (self.type_mappings.get(n.name)) |mapping| {
                try self.writer.writeAll(mapping.fsharp_type);
            } else {
                try self.writer.writeAll(n.name);
            }
        },
        .qualified => |q| {
            if (self.type_mappings.get(q.name)) |mapping| {
                try self.writer.writeAll(mapping.fsharp_type);
            } else if (self.resolveQualified(q.namespace, q.name)) |_| {
                try self.writer.writeAll(q.name);
            } else {
                try self.writer.print("{s}.{s} (* unresolved import *)", .{ q.namespace, q.name });
            }
        },
    }
}

fn emitDoc(self: *FsGen, doc: ?[]const u8) Error!void {
    const text = doc orelse return;
    if (std.mem.indexOfScalar(u8, text, '\n')) |_| {
        var it = std.mem.splitScalar(u8, text, '\n');
        while (it.next()) |line| {
            try self.writer.print("/// {s}\n", .{line});
        }
    } else {
        try self.writer.print("/// {s}\n", .{text});
    }
}

// =========================================================================
// Codec emission
// =========================================================================

fn emitCodecModule(self: *FsGen, name: []const u8, def: Ast.TypeDef, func_prefix: ?[]const u8) Error!void {
    const codec_name = try std.fmt.allocPrint(self.arena, "{s}Codec", .{name});

    try self.writer.print("\nmodule {s} =\n", .{codec_name});

    // encodeWith
    try self.writer.print("\n    let encodeWith (w: Cbor.Writer) (value: {s}) : unit =\n", .{name});
    try self.emitEncodeBody(name, def, func_prefix, "        ");

    // decodeWith
    try self.writer.print("\n    let decodeWith (r: Cbor.Reader) : {s} =\n", .{name});
    try self.emitDecodeBody(name, def, func_prefix, "        ");

    // encode (standalone)
    try self.writer.print("\n    let encode (value: {s}) : byte array =\n", .{name});
    try self.writer.writeAll("        let w = Cbor.Writer()\n");
    try self.writer.writeAll("        encodeWith w value\n");
    try self.writer.writeAll("        w.Finish()\n");

    // decode (standalone)
    try self.writer.print("\n    let decode (data: byte array) : {s} =\n", .{name});
    try self.writer.writeAll("        let r = Cbor.Reader(data)\n");
    try self.writer.writeAll("        decodeWith r\n");
}

fn emitRecursiveCodecGroup(self: *FsGen, group: topo.TypeGroup, type_map: *std.StringHashMap(Ast.TypeDef)) Error!void {
    // Build combined internal module name
    var combined_name: std.ArrayList(u8) = .{};
    for (group.names, 0..) |name, i| {
        if (i > 0) try combined_name.appendSlice(self.arena, "And");
        try combined_name.appendSlice(self.arena, name);
    }
    try combined_name.appendSlice(self.arena, "Codecs");
    const internal_name = try combined_name.toOwnedSlice(self.arena);

    // Internal module with `let rec ... and ...`
    try self.writer.print("\nmodule internal {s} =\n", .{internal_name});

    self.rec_group = group.names;
    defer self.rec_group = null;

    for (group.names, 0..) |name, i| {
        const def = type_map.get(name) orelse continue;
        const rec_kw = if (i == 0) "let rec" else "\n    and";

        try self.writer.print("\n    {s} encodeWith{s} (w: Cbor.Writer) (value: {s}) : unit =\n", .{ rec_kw, name, name });
        try self.emitEncodeBody(name, def, name, "        ");

        const dec_kw = if (i == 0 and group.names.len == 1) "" else "\n    and";
        _ = dec_kw;
    }

    // Decode functions — also need `let rec ... and ...` for mutual recursion
    for (group.names, 0..) |name, i| {
        const def = type_map.get(name) orelse continue;
        const kw = if (i == 0) "\n    and" else "\n    and";

        try self.writer.print("{s} decodeWith{s} (r: Cbor.Reader) : {s} =\n", .{ kw, name, name });
        try self.emitDecodeBody(name, def, name, "        ");
    }

    // Public per-type codec modules that delegate
    for (group.names) |name| {
        try self.writer.print("\nmodule {s}Codec =\n", .{name});
        try self.writer.print("\n    let encodeWith w v = {s}.encodeWith{s} w v\n", .{ internal_name, name });
        try self.writer.print("    let decodeWith r = {s}.decodeWith{s} r\n", .{ internal_name, name });
        try self.writer.print("\n    let encode (value: {s}) : byte array =\n", .{name});
        try self.writer.writeAll("        let w = Cbor.Writer()\n");
        try self.writer.print("        {s}.encodeWith{s} w value\n", .{ internal_name, name });
        try self.writer.writeAll("        w.Finish()\n");
        try self.writer.print("\n    let decode (data: byte array) : {s} =\n", .{name});
        try self.writer.writeAll("        let r = Cbor.Reader(data)\n");
        try self.writer.print("        {s}.decodeWith{s} r\n", .{ internal_name, name });
    }
}

// =========================================================================
// Encode bodies
// =========================================================================

fn emitEncodeBody(self: *FsGen, name: []const u8, def: Ast.TypeDef, func_prefix: ?[]const u8, indent: []const u8) Error!void {
    switch (def.ty) {
        .struct_ => |s| try self.emitStructEncodeBody(s, func_prefix, indent),
        .enum_ => try self.emitEnumEncodeBody(indent),
        .union_ => |u| try self.emitUnionEncodeBody(name, u, func_prefix, indent),
        else => {
            try self.writer.print("{s}", .{indent});
            try self.emitEncodeExpr(def.ty, "value", func_prefix, indent);
            try self.writer.writeAll("\n");
        },
    }
}

fn emitStructEncodeBody(self: *FsGen, def: *const Ast.StructDef, func_prefix: ?[]const u8, indent: []const u8) Error!void {
    if (def.fields.len == 0) {
        try self.writer.print("{s}w.WriteArrayHeader(0)\n", .{indent});
    } else {
        const max_rank = maxRank(def);
        try self.writer.print("{s}w.WriteArrayHeader({d})\n", .{ indent, max_rank + 1 });
        var rank: u64 = 0;
        while (rank <= max_rank) : (rank += 1) {
            if (findFieldByRank(def, rank)) |field| {
                const fname = try self.toPascalCase(field.name);
                const access = try std.fmt.allocPrint(self.arena, "value.{s}", .{fname});
                try self.writer.print("{s}", .{indent});
                try self.emitEncodeExpr(field.ty, access, func_prefix, indent);
                try self.writer.writeAll("\n");
            } else {
                try self.writer.print("{s}w.WriteNull()\n", .{indent});
            }
        }
    }
}

fn emitEnumEncodeBody(self: *FsGen, indent: []const u8) Error!void {
    try self.writer.print("{s}w.WriteUvarint(uint64 value)\n", .{indent});
}

fn emitUnionEncodeBody(self: *FsGen, name: []const u8, def: *const Ast.UnionDef, func_prefix: ?[]const u8, indent: []const u8) Error!void {
    try self.writer.print("{s}match value with\n", .{indent});
    for (def.variants) |v| {
        const vname = try self.toPascalCase(v.name);
        if (v.payload) |payload| {
            const variant_indent = try std.fmt.allocPrint(self.arena, "{s}    ", .{indent});
            try self.writer.print("{s}| {s}.{s} v ->\n", .{ indent, name, vname });
            try self.writer.print("{s}w.WriteTagHeader({d}u)\n", .{ variant_indent, v.tag });
            try self.writer.print("{s}", .{variant_indent});
            try self.emitEncodeExpr(payload, "v", func_prefix, variant_indent);
            try self.writer.writeAll("\n");
        } else {
            try self.writer.print("{s}| {s}.{s} -> w.WriteUvarint({d}UL)\n", .{ indent, name, vname, v.tag });
        }
    }
}

fn emitEncodeExpr(self: *FsGen, ty: Ast.TypeExpr, access: []const u8, func_prefix: ?[]const u8, indent: []const u8) Error!void {
    switch (ty) {
        .bool => try self.writer.print("w.WriteBool({s})", .{access}),
        .string => try self.writer.print("w.WriteString({s})", .{access}),
        .int => |i| {
            switch (i.kind) {
                .uvar => if (self.varint_as_number) {
                    try self.writer.print("w.WriteUvarint(uint64 {s})", .{access});
                } else {
                    try self.writer.print("w.WriteUvarint({s})", .{access});
                },
                .ivar => if (self.varint_as_number) {
                    try self.writer.print("w.WriteIvarint(int64 {s})", .{access});
                } else {
                    try self.writer.print("w.WriteIvarint({s})", .{access});
                },
                else => {
                    const fn_name = switch (i.kind) {
                        .u8 => "WriteU8",
                        .u16 => "WriteU16",
                        .u32 => "WriteU32",
                        .u64 => "WriteU64",
                        .i8 => "WriteI8",
                        .i16 => "WriteI16",
                        .i32 => "WriteI32",
                        .i64 => "WriteI64",
                        else => unreachable,
                    };
                    try self.writer.print("w.{s}({s})", .{ fn_name, access });
                },
            }
        },
        .float => |f| {
            const fn_name = switch (f.kind) {
                .f16 => "WriteF16",
                .f32 => "WriteF32",
                .f64 => "WriteF64",
            };
            try self.writer.print("w.{s}({s})", .{ fn_name, access });
        },
        .option => |o| {
            const deeper = try std.fmt.allocPrint(self.arena, "{s}    ", .{indent});
            try self.writer.print("match {s} with\n", .{access});
            try self.writer.print("{s}| ValueNone -> w.WriteByte(0x00uy)\n", .{indent});
            try self.writer.print("{s}| ValueSome v ->\n", .{indent});
            try self.writer.print("{s}w.WriteTagHeader(1u)\n", .{deeper});
            try self.writer.print("{s}", .{deeper});
            try self.emitEncodeExpr(o.child, "v", func_prefix, deeper);
        },
        .array => |a| {
            if (isU8Array(a.getElement())) {
                try self.writer.print("w.WriteBytes({s})", .{access});
            } else {
                const lv = try std.fmt.allocPrint(self.arena, "_i{d}", .{self.loop_depth});
                self.loop_depth += 1;
                defer self.loop_depth -= 1;
                const deeper = try std.fmt.allocPrint(self.arena, "{s}    ", .{indent});
                switch (a.*) {
                    .variable => |v| {
                        try self.writer.print("w.WriteArrayHeader(({s}).Length)\n", .{access});
                        try self.writer.print("{s}for {s} = 0 to ({s}).Length - 1 do\n{s}", .{ indent, lv, access, deeper });
                        const elem_access = try std.fmt.allocPrint(self.arena, "({s}).[{s}]", .{ access, lv });
                        try self.emitEncodeExpr(v.element, elem_access, func_prefix, deeper);
                    },
                    .fixed => |f| {
                        try self.writer.print("w.WriteArrayHeader({d})\n", .{f.len});
                        try self.writer.print("{s}for {s} = 0 to {d} - 1 do\n{s}", .{ indent, lv, f.len, deeper });
                        const elem_access = try std.fmt.allocPrint(self.arena, "({s}).[{s}]", .{ access, lv });
                        try self.emitEncodeExpr(f.element, elem_access, func_prefix, deeper);
                    },
                    .external_len => |e| {
                        try self.writer.writeAll("w.WriteByte(0x9Fuy)\n");
                        try self.writer.print("{s}for {s} = 0 to ({s}).Length - 1 do\n{s}", .{ indent, lv, access, deeper });
                        const elem_access = try std.fmt.allocPrint(self.arena, "({s}).[{s}]", .{ access, lv });
                        try self.emitEncodeExpr(e.element, elem_access, func_prefix, deeper);
                        try self.writer.print("\n{s}w.WriteByte(0xFFuy)", .{indent});
                    },
                }
            }
        },
        .struct_ => |s| {
            if (self.inline_struct_names.get(s)) |sname| {
                try self.emitCodecCall(sname, access, func_prefix, "encodeWith");
            }
        },
        .enum_ => |e| {
            if (self.inline_enum_names.get(e)) |ename| {
                try self.emitCodecCall(ename, access, func_prefix, "encodeWith");
            }
        },
        .union_ => |u| {
            if (self.inline_union_names.get(u)) |uname| {
                try self.emitCodecCall(uname, access, func_prefix, "encodeWith");
            }
        },
        .named => |n| {
            if (self.type_mappings.get(n.name)) |mapping| {
                try self.writer.print("{s}.encodeWith w {s}", .{ mapping.codec_module, access });
            } else {
                try self.emitCodecCall(n.name, access, func_prefix, "encodeWith");
            }
        },
        .qualified => |q| {
            if (self.type_mappings.get(q.name)) |mapping| {
                try self.writer.print("{s}.encodeWith w {s}", .{ mapping.codec_module, access });
            } else if (self.resolveQualified(q.namespace, q.name)) |_| {
                try self.emitCodecCall(q.name, access, func_prefix, "encodeWith");
            }
        },
    }
}

/// Emit a codec function call. If the target is in the current recursive group,
/// use the bare form (e.g., `encodeWithFoo`), otherwise use `FooCodec.encodeWith`.
fn emitCodecCall(self: *FsGen, target_name: []const u8, access: []const u8, func_prefix: ?[]const u8, func_name: []const u8) Error!void {
    _ = func_prefix;
    if (self.isInRecGroup(target_name)) {
        try self.writer.print("{s}{s} w {s}", .{ func_name, target_name, access });
    } else {
        try self.writer.print("{s}Codec.{s} w {s}", .{ target_name, func_name, access });
    }
}

// =========================================================================
// Decode bodies
// =========================================================================

fn emitDecodeBody(self: *FsGen, name: []const u8, def: Ast.TypeDef, func_prefix: ?[]const u8, indent: []const u8) Error!void {
    switch (def.ty) {
        .struct_ => |s| try self.emitStructDecodeBody(s, func_prefix, indent),
        .enum_ => try self.emitEnumDecodeBody(indent),
        .union_ => |u| try self.emitUnionDecodeBody(name, u, func_prefix, indent),
        else => {
            try self.writer.print("{s}", .{indent});
            try self.emitDecodeExpr(def.ty, func_prefix);
            try self.writer.writeAll("\n");
        },
    }
}

fn emitStructDecodeBody(self: *FsGen, def: *const Ast.StructDef, func_prefix: ?[]const u8, indent: []const u8) Error!void {
    try self.writer.print("{s}let al = r.ReadArrayHeader()\n", .{indent});

    if (def.fields.len == 0) {
        try self.writer.print("{s}for _ = 0 to al - 1 do r.Skip()\n", .{indent});
        try self.writer.print("{s}{{ _empty = 0uy }}\n", .{indent});
        return;
    }

    const max_rank = maxRank(def);

    // Declare mutable locals
    for (def.fields) |field| {
        const fname = try self.toPascalCase(field.name);
        try self.writer.print("{s}let mutable _{s} = ", .{ indent, fname });
        if (field.ty == .option) {
            try self.writer.writeAll("ValueNone\n");
        } else {
            try self.writer.writeAll("Unchecked.defaultof<");
            try self.emitTypeRef(field.ty);
            try self.writer.writeAll(">\n");
        }
    }

    // Read fields by rank
    var rank: u64 = 0;
    while (rank <= max_rank) : (rank += 1) {
        try self.writer.print("{s}if al > {d} then ", .{ indent, rank });
        if (findFieldByRank(def, rank)) |field| {
            const fname = try self.toPascalCase(field.name);
            try self.writer.print("_{s} <- ", .{fname});
            try self.emitDecodeExpr(field.ty, func_prefix);
            try self.writer.writeAll("\n");
        } else {
            try self.writer.writeAll("r.Skip()\n");
        }
    }

    // Skip extra fields
    try self.writer.print("{s}for _ = {d} to al - 1 do r.Skip()\n", .{ indent, max_rank + 1 });

    // Construct record
    try self.writer.print("{s}{{ ", .{indent});
    for (def.fields, 0..) |field, i| {
        const fname = try self.toPascalCase(field.name);
        try self.writer.print("{s} = _{s}", .{ fname, fname });
        if (i < def.fields.len - 1) try self.writer.writeAll("; ");
    }
    try self.writer.writeAll(" }\n");
}

fn emitEnumDecodeBody(self: *FsGen, indent: []const u8) Error!void {
    try self.writer.print("{s}enum<_>(int (r.ReadUvarint()))\n", .{indent});
}

fn emitUnionDecodeBody(self: *FsGen, name: []const u8, def: *const Ast.UnionDef, func_prefix: ?[]const u8, indent: []const u8) Error!void {
    try self.writer.print("{s}let b = r.PeekByte()\n", .{indent});
    try self.writer.print("{s}let maj = b >>> 5\n", .{indent});
    try self.writer.print("{s}if maj = 6uy then\n", .{indent});
    try self.writer.print("{s}    let tag = r.ReadTagHeader()\n", .{indent});
    try self.writer.print("{s}    match tag with\n", .{indent});

    // Variants with payloads (tag major type 6)
    for (def.variants) |v| {
        if (v.payload) |payload| {
            const vname = try self.toPascalCase(v.name);
            try self.writer.print("{s}    | {d}u -> {s}.{s}(", .{ indent, v.tag, name, vname });
            try self.emitDecodeExpr(payload, func_prefix);
            try self.writer.writeAll(")\n");
        }
    }
    try self.writer.print("{s}    | _ -> failwithf \"unknown union tag %%d\" (int tag)\n", .{indent});

    try self.writer.print("{s}elif maj = 0uy then\n", .{indent});
    try self.writer.print("{s}    let tag = int (r.ReadUvarint())\n", .{indent});
    try self.writer.print("{s}    match tag with\n", .{indent});

    // Variants without payloads (tag major type 0 — unsigned int)
    for (def.variants) |v| {
        if (v.payload == null) {
            const vname = try self.toPascalCase(v.name);
            try self.writer.print("{s}    | {d} -> {s}.{s}\n", .{ indent, v.tag, name, vname });
        }
    }
    try self.writer.print("{s}    | _ -> failwithf \"unknown union tag %%d\" tag\n", .{indent});

    try self.writer.print("{s}else\n", .{indent});
    try self.writer.print("{s}    failwith \"expected union\"\n", .{indent});
}

fn emitDecodeExpr(self: *FsGen, ty: Ast.TypeExpr, func_prefix: ?[]const u8) Error!void {
    switch (ty) {
        .bool => try self.writer.writeAll("r.ReadBool()"),
        .string => try self.writer.writeAll("r.ReadString()"),
        .int => |i| {
            switch (i.kind) {
                .uvar => if (self.varint_as_number)
                    try self.writer.writeAll("int (r.ReadUvarint())")
                else
                    try self.writer.writeAll("r.ReadUvarint()"),
                .ivar => if (self.varint_as_number)
                    try self.writer.writeAll("int (r.ReadIvarint())")
                else
                    try self.writer.writeAll("r.ReadIvarint()"),
                else => {
                    const fn_name = switch (i.kind) {
                        .u8 => "r.ReadU8()",
                        .u16 => "r.ReadU16()",
                        .u32 => "r.ReadU32()",
                        .u64 => "r.ReadU64()",
                        .i8 => "r.ReadI8()",
                        .i16 => "r.ReadI16()",
                        .i32 => "r.ReadI32()",
                        .i64 => "r.ReadI64()",
                        else => unreachable,
                    };
                    try self.writer.writeAll(fn_name);
                },
            }
        },
        .float => |f| {
            const fn_name = switch (f.kind) {
                .f16 => "r.ReadF16()",
                .f32 => "r.ReadF32()",
                .f64 => "r.ReadF64()",
            };
            try self.writer.writeAll(fn_name);
        },
        .option => |o| {
            try self.writer.writeAll("(if r.PeekByte() = 0x00uy then (r.ReadByte() |> ignore; ValueNone) else (r.ReadByte() |> ignore; ValueSome(");
            try self.emitDecodeExpr(o.child, func_prefix);
            try self.writer.writeAll(")))");
        },
        .array => |a| {
            if (isU8Array(a.getElement())) {
                try self.writer.writeAll("r.ReadBytes()");
            } else switch (a.*) {
                .variable => |v| {
                    try self.writer.writeAll("(let _n = r.ReadArrayHeader() in Array.init _n (fun _ -> ");
                    try self.emitDecodeExpr(v.element, func_prefix);
                    try self.writer.writeAll("))");
                },
                .fixed => |f| {
                    try self.writer.print("(let _ = r.ReadArrayHeader() in Array.init {d} (fun _ -> ", .{f.len});
                    try self.emitDecodeExpr(f.element, func_prefix);
                    try self.writer.writeAll("))");
                },
                .external_len => |e| {
                    try self.writer.writeAll("(if r.ReadByte() <> 0x9Fuy then failwith \"expected indefinite array\"\n");
                    try self.writer.writeAll("         let _a = System.Collections.Generic.List<_>()\n");
                    try self.writer.writeAll("         while r.PeekByte() <> 0xFFuy do\n");
                    try self.writer.writeAll("             _a.Add(");
                    try self.emitDecodeExpr(e.element, func_prefix);
                    try self.writer.writeAll(")\n");
                    try self.writer.writeAll("         r.ReadByte() |> ignore\n");
                    try self.writer.writeAll("         _a.ToArray())");
                },
            }
        },
        .struct_ => |s| {
            if (self.inline_struct_names.get(s)) |sname| {
                try self.emitDecodeCall(sname, func_prefix);
            }
        },
        .enum_ => |e| {
            if (self.inline_enum_names.get(e)) |ename| {
                try self.emitDecodeCall(ename, func_prefix);
            }
        },
        .union_ => |u| {
            if (self.inline_union_names.get(u)) |uname| {
                try self.emitDecodeCall(uname, func_prefix);
            }
        },
        .named => |n| {
            if (self.type_mappings.get(n.name)) |mapping| {
                try self.writer.print("{s}.decodeWith r", .{mapping.codec_module});
            } else {
                try self.emitDecodeCall(n.name, func_prefix);
            }
        },
        .qualified => |q| {
            if (self.type_mappings.get(q.name)) |mapping| {
                try self.writer.print("{s}.decodeWith r", .{mapping.codec_module});
            } else if (self.resolveQualified(q.namespace, q.name)) |_| {
                try self.emitDecodeCall(q.name, func_prefix);
            }
        },
    }
}

fn emitDecodeCall(self: *FsGen, target_name: []const u8, func_prefix: ?[]const u8) Error!void {
    _ = func_prefix;
    if (self.isInRecGroup(target_name)) {
        try self.writer.print("decodeWith{s} r", .{target_name});
    } else {
        try self.writer.print("{s}Codec.decodeWith r", .{target_name});
    }
}

// =========================================================================
// Helpers
// =========================================================================

fn maxRank(def: *const Ast.StructDef) u64 {
    var max: u64 = 0;
    for (def.fields) |field| {
        if (field.rank > max) max = field.rank;
    }
    return if (def.fields.len == 0) 0 else max;
}

fn findFieldByRank(def: *const Ast.StructDef, rank: u64) ?Ast.FieldDef {
    for (def.fields) |field| {
        if (field.rank == rank) return field;
    }
    return null;
}

fn sanitizeFieldName(self: *FsGen, name: []const u8) Error![]const u8 {
    if (name.len > 0 and std.ascii.isDigit(name[0])) {
        return try std.fmt.allocPrint(self.arena, "_{s}", .{name});
    }
    return name;
}

/// Convert a camelCase field name to PascalCase.
fn toPascalCase(self: *FsGen, name: []const u8) Error![]const u8 {
    if (name.len == 0) return name;
    // If first char is a digit, prefix with underscore
    if (std.ascii.isDigit(name[0])) {
        return try std.fmt.allocPrint(self.arena, "_{s}", .{name});
    }
    if (std.ascii.isUpper(name[0])) return name;
    const upper = std.ascii.toUpper(name[0]);
    return try std.fmt.allocPrint(self.arena, "{c}{s}", .{ upper, name[1..] });
}

/// Convert a PascalCase name to camelCase.
fn toLowerCamelCase(self: *FsGen, name: []const u8) Error![]const u8 {
    if (name.len == 0) return name;
    if (std.ascii.isLower(name[0])) return name;
    const lower = std.ascii.toLower(name[0]);
    return try std.fmt.allocPrint(self.arena, "{c}{s}", .{ lower, name[1..] });
}

/// Check if a type expression is `u8` (for byte array special-casing).
fn isU8Array(element: Ast.TypeExpr) bool {
    return element == .int and element.int.kind == .u8;
}

/// Check if a type name is in the current recursive codec group.
fn isInRecGroup(self: *FsGen, name: []const u8) bool {
    const group = self.rec_group orelse return false;
    for (group) |member| {
        if (std.mem.eql(u8, member, name)) return true;
    }
    return false;
}

/// Look up a qualified type reference in imported schemas.
fn resolveQualified(self: *FsGen, namespace: []const u8, name: []const u8) ?Ast.TypeDef {
    const imported_schema = self.imports.get(namespace) orelse return null;
    for (imported_schema.definitions) |def| {
        if (std.mem.eql(u8, def.name, name)) return def;
    }
    return null;
}
