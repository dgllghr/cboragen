const std = @import("std");
const parser = @import("parser");
const Ast = parser.Ast;

const TsGen = @This();

writer: std.io.AnyWriter,
schema: Ast.Schema,
arena: std.mem.Allocator,
indent: u32,
varint_as_number: bool,
loop_depth: u32,

/// Namespace → Schema for imported schemas.
imports: std.StringHashMap(Ast.Schema),

/// Inline types discovered during pass 1, keyed by pointer identity.
inline_struct_names: std.AutoHashMap(*const Ast.StructDef, []const u8),
inline_enum_names: std.AutoHashMap(*const Ast.EnumDef, []const u8),
inline_union_names: std.AutoHashMap(*const Ast.UnionDef, []const u8),

/// Ordered list of inline types to emit (preserves discovery order).
inline_structs: std.ArrayList(InlineStruct),
inline_enums: std.ArrayList(InlineEnum),
inline_unions: std.ArrayList(InlineUnion),

const InlineStruct = struct { name: []const u8, def: *const Ast.StructDef };
const InlineEnum = struct { name: []const u8, def: *const Ast.EnumDef };
const InlineUnion = struct { name: []const u8, def: *const Ast.UnionDef };

pub const Options = struct {
    varint_as_number: bool = false,
};

pub fn init(
    writer: std.io.AnyWriter,
    schema: Ast.Schema,
    imports: std.StringHashMap(Ast.Schema),
    arena: std.mem.Allocator,
    options: Options,
) TsGen {
    return .{
        .writer = writer,
        .schema = schema,
        .arena = arena,
        .indent = 0,
        .varint_as_number = options.varint_as_number,
        .loop_depth = 0,
        .imports = imports,
        .inline_struct_names = std.AutoHashMap(*const Ast.StructDef, []const u8).init(arena),
        .inline_enum_names = std.AutoHashMap(*const Ast.EnumDef, []const u8).init(arena),
        .inline_union_names = std.AutoHashMap(*const Ast.UnionDef, []const u8).init(arena),
        .inline_structs = .{},
        .inline_enums = .{},
        .inline_unions = .{},
    };
}

const Error = std.io.AnyWriter.Error || std.mem.Allocator.Error;

pub fn generate(self: *TsGen) Error!void {
    // Pass 1: collect inline types — imported schemas first, then main
    var import_it = self.imports.iterator();
    while (import_it.next()) |entry| {
        for (entry.value_ptr.definitions) |def| {
            try self.collectInlineTypes(def.name, def.ty);
        }
    }
    for (self.schema.definitions) |def| {
        try self.collectInlineTypes(def.name, def.ty);
    }

    // Pass 2: emit TypeScript
    try self.writer.writeAll("// Generated by cboragen — do not edit\n\n");

    // Runtime
    try self.writer.writeAll("import { _reset, _finish, _wb, _eBool, _eNull, _eU8, _eU16, _eU32, _eU64, _eI8, _eI16, _eI32, _eI64, _eUvar, _eIvar, _eF16, _eF32, _eF64, _eStr, _eBytes, _eArrHdr, _eTagHdr, _dInit, _rb, _r16, _r32, _dBool, _dU8, _dU16, _dU32, _dU64, _dI8, _dI16, _dI32, _dI64, _dUvar, _dIvar, _dF16, _dF32, _dF64, _dStr, _dBytes, _dArrHdr, _dSkip, _dPeek, _dAdv } from \"@cboragen/runtime\";\n");

    // Types
    try self.writer.writeAll("\n// === Types ===\n\n");
    // Inline types first
    for (self.inline_structs.items) |entry| {
        try self.emitStructType(entry.name, entry.def, null);
    }
    for (self.inline_enums.items) |entry| {
        try self.emitEnumType(entry.name, entry.def, null);
    }
    for (self.inline_unions.items) |entry| {
        try self.emitUnionType(entry.name, entry.def, null);
    }
    // Imported top-level types
    var import_it2 = self.imports.iterator();
    while (import_it2.next()) |entry| {
        for (entry.value_ptr.definitions) |def| {
            try self.emitTypeDef(def);
        }
    }
    // Main schema top-level types
    for (self.schema.definitions) |def| {
        try self.emitTypeDef(def);
    }

    // Encoders
    try self.writer.writeAll("\n// === Encoders ===\n");
    for (self.inline_structs.items) |entry| {
        try self.emitStructEncoder(entry.name, entry.def);
    }
    for (self.inline_enums.items) |entry| {
        try self.emitEnumEncoder(entry.name, entry.def);
    }
    for (self.inline_unions.items) |entry| {
        try self.emitUnionEncoder(entry.name, entry.def);
    }
    var import_it3 = self.imports.iterator();
    while (import_it3.next()) |entry| {
        for (entry.value_ptr.definitions) |def| {
            try self.emitEncoderForDef(def);
        }
    }
    for (self.schema.definitions) |def| {
        try self.emitEncoderForDef(def);
    }

    // Decoders
    try self.writer.writeAll("\n// === Decoders ===\n");
    for (self.inline_structs.items) |entry| {
        try self.emitStructDecoder(entry.name, entry.def);
    }
    for (self.inline_enums.items) |entry| {
        try self.emitEnumDecoder(entry.name, entry.def);
    }
    for (self.inline_unions.items) |entry| {
        try self.emitUnionDecoder(entry.name, entry.def);
    }
    var import_it4 = self.imports.iterator();
    while (import_it4.next()) |entry| {
        for (entry.value_ptr.definitions) |def| {
            try self.emitDecoderForDef(def);
        }
    }
    for (self.schema.definitions) |def| {
        try self.emitDecoderForDef(def);
    }
}

// =========================================================================
// Pass 1: Collect inline types
// =========================================================================

fn collectInlineTypes(self: *TsGen, parent_name: []const u8, ty: Ast.TypeExpr) Error!void {
    switch (ty) {
        .struct_ => |s| {
            for (s.fields) |field| {
                try self.collectInlineTypesField(parent_name, field);
            }
        },
        .enum_ => {},
        .union_ => |u| {
            for (u.variants) |v| {
                if (v.payload) |payload| {
                    try self.collectInlineTypesVariant(parent_name, v.name, payload);
                }
            }
        },
        .array => |a| {
            try self.collectInlineTypes(parent_name, a.getElement());
        },
        .option => |o| {
            try self.collectInlineTypes(parent_name, o.child);
        },
        else => {},
    }
}

fn collectInlineTypesField(self: *TsGen, parent_name: []const u8, field: Ast.FieldDef) Error!void {
    switch (field.ty) {
        .struct_ => |s| {
            const fname = try self.sanitizeFieldName(field.name);
            const name = try std.fmt.allocPrint(self.arena, "{s}_{s}", .{ parent_name, fname });
            try self.inline_struct_names.put(s, name);
            try self.inline_structs.append(self.arena, .{ .name = name, .def = s });
            for (s.fields) |f| {
                try self.collectInlineTypesField(name, f);
            }
        },
        .enum_ => |e| {
            const fname = try self.sanitizeFieldName(field.name);
            const name = try std.fmt.allocPrint(self.arena, "{s}_{s}", .{ parent_name, fname });
            try self.inline_enum_names.put(e, name);
            try self.inline_enums.append(self.arena, .{ .name = name, .def = e });
        },
        .union_ => |u| {
            const fname = try self.sanitizeFieldName(field.name);
            const name = try std.fmt.allocPrint(self.arena, "{s}_{s}", .{ parent_name, fname });
            try self.inline_union_names.put(u, name);
            try self.inline_unions.append(self.arena, .{ .name = name, .def = u });
            for (u.variants) |v| {
                if (v.payload) |payload| {
                    try self.collectInlineTypesVariant(name, v.name, payload);
                }
            }
        },
        .array => |a| {
            try self.collectInlineTypesElement(parent_name, field.name, a.getElement());
        },
        .option => |o| {
            try self.collectInlineTypesOption(parent_name, field.name, o.child);
        },
        else => {},
    }
}

fn collectInlineTypesElement(self: *TsGen, parent_name: []const u8, field_name: []const u8, ty: Ast.TypeExpr) Error!void {
    switch (ty) {
        .struct_ => |s| {
            const fn_name = try self.sanitizeFieldName(field_name);
            const name = try std.fmt.allocPrint(self.arena, "{s}_{s}", .{ parent_name, fn_name });
            if (!self.inline_struct_names.contains(s)) {
                try self.inline_struct_names.put(s, name);
                try self.inline_structs.append(self.arena, .{ .name = name, .def = s });
                for (s.fields) |f| {
                    try self.collectInlineTypesField(name, f);
                }
            }
        },
        .enum_ => |e| {
            const fn_name = try self.sanitizeFieldName(field_name);
            const name = try std.fmt.allocPrint(self.arena, "{s}_{s}", .{ parent_name, fn_name });
            if (!self.inline_enum_names.contains(e)) {
                try self.inline_enum_names.put(e, name);
                try self.inline_enums.append(self.arena, .{ .name = name, .def = e });
            }
        },
        .union_ => |u| {
            const fn_name = try self.sanitizeFieldName(field_name);
            const name = try std.fmt.allocPrint(self.arena, "{s}_{s}", .{ parent_name, fn_name });
            if (!self.inline_union_names.contains(u)) {
                try self.inline_union_names.put(u, name);
                try self.inline_unions.append(self.arena, .{ .name = name, .def = u });
                for (u.variants) |v| {
                    if (v.payload) |payload| {
                        try self.collectInlineTypesVariant(name, v.name, payload);
                    }
                }
            }
        },
        .array => |a| {
            try self.collectInlineTypesElement(parent_name, field_name, a.getElement());
        },
        .option => |o| {
            try self.collectInlineTypesOption(parent_name, field_name, o.child);
        },
        else => {},
    }
}

fn collectInlineTypesOption(self: *TsGen, parent_name: []const u8, field_name: []const u8, ty: Ast.TypeExpr) Error!void {
    switch (ty) {
        .option => |o| try self.collectInlineTypesOption(parent_name, field_name, o.child),
        else => try self.collectInlineTypesElement(parent_name, field_name, ty),
    }
}

fn collectInlineTypesVariant(self: *TsGen, parent_name: []const u8, variant_name: []const u8, ty: Ast.TypeExpr) Error!void {
    switch (ty) {
        .struct_ => |s| {
            const name = try std.fmt.allocPrint(self.arena, "{s}_{s}", .{ parent_name, variant_name });
            try self.inline_struct_names.put(s, name);
            try self.inline_structs.append(self.arena, .{ .name = name, .def = s });
            for (s.fields) |f| {
                try self.collectInlineTypesField(name, f);
            }
        },
        .enum_ => |e| {
            const name = try std.fmt.allocPrint(self.arena, "{s}_{s}", .{ parent_name, variant_name });
            try self.inline_enum_names.put(e, name);
            try self.inline_enums.append(self.arena, .{ .name = name, .def = e });
        },
        .union_ => |u| {
            const name = try std.fmt.allocPrint(self.arena, "{s}_{s}", .{ parent_name, variant_name });
            try self.inline_union_names.put(u, name);
            try self.inline_unions.append(self.arena, .{ .name = name, .def = u });
            for (u.variants) |v| {
                if (v.payload) |payload| {
                    try self.collectInlineTypesVariant(name, v.name, payload);
                }
            }
        },
        .array => |a| {
            try self.collectInlineTypesElement(parent_name, variant_name, a.getElement());
        },
        .option => |o| {
            try self.collectInlineTypesOption(parent_name, variant_name, o.child);
        },
        else => {},
    }
}

// =========================================================================
// Pass 2: Emit TypeScript types
// =========================================================================

fn emitTypeDef(self: *TsGen, def: Ast.TypeDef) Error!void {
    switch (def.ty) {
        .struct_ => |s| try self.emitStructType(def.name, s, def.doc),
        .enum_ => |e| try self.emitEnumType(def.name, e, def.doc),
        .union_ => |u| try self.emitUnionType(def.name, u, def.doc),
        else => {
            try self.emitDoc(def.doc);
            try self.writer.print("export type {s} = ", .{def.name});
            try self.emitTypeRef(def.ty);
            try self.writer.writeAll(";\n\n");
        },
    }
}

fn emitStructType(self: *TsGen, name: []const u8, def: *const Ast.StructDef, doc: ?[]const u8) Error!void {
    try self.emitDoc(doc);
    try self.writer.print("export interface {s} {{\n", .{name});
    for (def.fields) |field| {
        try self.emitDoc(field.doc);
        const fname = try self.sanitizeFieldName(field.name);
        try self.writer.print("  {s}: ", .{fname});
        try self.emitTypeRef(field.ty);
        try self.writer.writeAll(";\n");
    }
    try self.writer.writeAll("}\n\n");
}

fn emitEnumType(self: *TsGen, name: []const u8, def: *const Ast.EnumDef, doc: ?[]const u8) Error!void {
    try self.emitDoc(doc);
    try self.writer.print("export const {s} = {{\n", .{name});
    for (def.variants) |v| {
        try self.emitDoc(v.doc);
        try self.writer.print("  {s}: {d},\n", .{ v.name, v.tag });
    }
    try self.writer.writeAll("} as const;\n");
    try self.writer.print("export type {s} = (typeof {s})[keyof typeof {s}];\n\n", .{ name, name, name });
}

fn emitUnionType(self: *TsGen, name: []const u8, def: *const Ast.UnionDef, doc: ?[]const u8) Error!void {
    try self.emitDoc(doc);
    try self.writer.print("export type {s} =\n", .{name});
    for (def.variants) |v| {
        try self.emitDoc(v.doc);
        if (v.payload) |payload| {
            try self.writer.print("  | {{ tag: \"{s}\"; value: ", .{v.name});
            try self.emitTypeRef(payload);
            try self.writer.writeAll(" }\n");
        } else {
            try self.writer.print("  | {{ tag: \"{s}\" }}\n", .{v.name});
        }
    }
    try self.writer.writeAll(";\n\n");
}

fn emitTypeRef(self: *TsGen, ty: Ast.TypeExpr) Error!void {
    switch (ty) {
        .bool => try self.writer.writeAll("boolean"),
        .string => try self.writer.writeAll("string"),
        .bytes => try self.writer.writeAll("Uint8Array"),
        .int => |i| {
            switch (i.kind) {
                .u8, .u16, .u32, .i8, .i16, .i32 => try self.writer.writeAll("number"),
                .u64, .i64 => try self.writer.writeAll("bigint"),
                .uvar, .ivar => try self.writer.writeAll(if (self.varint_as_number) "number" else "bigint"),
            }
        },
        .float => try self.writer.writeAll("number"),
        .struct_ => |s| {
            if (self.inline_struct_names.get(s)) |name| {
                try self.writer.writeAll(name);
            } else {
                try self.writer.writeAll("unknown /* inline struct */");
            }
        },
        .enum_ => |e| {
            if (self.inline_enum_names.get(e)) |name| {
                try self.writer.writeAll(name);
            } else {
                try self.writer.writeAll("unknown /* inline enum */");
            }
        },
        .union_ => |u| {
            if (self.inline_union_names.get(u)) |name| {
                try self.writer.writeAll(name);
            } else {
                try self.writer.writeAll("unknown /* inline union */");
            }
        },
        .option => |o| {
            try self.emitTypeRef(o.child);
            try self.writer.writeAll(" | null");
        },
        .array => |a| {
            try self.emitTypeRef(a.getElement());
            try self.writer.writeAll("[]");
        },
        .named => |n| {
            try self.writer.writeAll(n.name);
        },
        .qualified => |q| {
            if (self.resolveQualified(q.namespace, q.name)) |_| {
                try self.writer.writeAll(q.name);
            } else {
                try self.writer.print("{s}.{s} /* TODO: unresolved import */", .{ q.namespace, q.name });
            }
        },
    }
}

fn emitDoc(self: *TsGen, doc: ?[]const u8) Error!void {
    const text = doc orelse return;
    if (std.mem.indexOfScalar(u8, text, '\n')) |_| {
        try self.writer.writeAll("/**\n");
        var it = std.mem.splitScalar(u8, text, '\n');
        while (it.next()) |line| {
            try self.writer.print(" * {s}\n", .{line});
        }
        try self.writer.writeAll(" */\n");
    } else {
        try self.writer.print("/** {s} */\n", .{text});
    }
}

// =========================================================================
// Encoders
// =========================================================================

fn emitEncoderForDef(self: *TsGen, def: Ast.TypeDef) Error!void {
    switch (def.ty) {
        .struct_ => |s| try self.emitStructEncoder(def.name, s),
        .enum_ => |e| try self.emitEnumEncoder(def.name, e),
        .union_ => |u| try self.emitUnionEncoder(def.name, u),
        else => {
            // Type alias — generate internal + public encoder
            try self.writer.print("\nfunction _enc{s}(v: {s}): void {{ ", .{ def.name, def.name });
            try self.emitEncodeExpr(def.ty, "v");
            try self.writer.writeAll("; }\n");
            try self.writer.print("\nexport function encode{s}(value: {s}): Uint8Array {{\n", .{ def.name, def.name });
            try self.writer.print("  _reset();\n  _enc{s}(value);\n  return _finish();\n}}\n", .{def.name});
        },
    }
}

fn emitStructEncoder(self: *TsGen, name: []const u8, def: *const Ast.StructDef) Error!void {
    try self.writer.print("\nfunction _enc{s}(v: {s}): void {{\n", .{ name, name });
    if (def.fields.len == 0) {
        try self.writer.writeAll("  _eArrHdr(0);\n");
    } else {
        const max_rank = self.maxRank(def);
        try self.writer.print("  _eArrHdr({d});\n", .{max_rank + 1});
        var rank: u64 = 0;
        while (rank <= max_rank) : (rank += 1) {
            if (self.findFieldByRank(def, rank)) |field| {
                const fname = try self.sanitizeFieldName(field.name);
                try self.writer.writeAll("  ");
                const access = try std.fmt.allocPrint(self.arena, "v.{s}", .{fname});
                try self.emitEncodeExpr(field.ty, access);
                try self.writer.writeAll(";\n");
            } else {
                try self.writer.writeAll("  _eNull();\n");
            }
        }
    }
    try self.writer.writeAll("}\n");
    try self.writer.print("\nexport function encode{s}(value: {s}): Uint8Array {{\n", .{ name, name });
    try self.writer.print("  _reset();\n  _enc{s}(value);\n  return _finish();\n}}\n", .{name});
}

fn emitEnumEncoder(self: *TsGen, name: []const u8, def: *const Ast.EnumDef) Error!void {
    _ = def;
    try self.writer.print("\nfunction _enc{s}(v: {s}): void {{ _eUvar(BigInt(v)); }}\n", .{ name, name });
    try self.writer.print("\nexport function encode{s}(value: {s}): Uint8Array {{\n", .{ name, name });
    try self.writer.print("  _reset();\n  _enc{s}(value);\n  return _finish();\n}}\n", .{name});
}

fn emitUnionEncoder(self: *TsGen, name: []const u8, def: *const Ast.UnionDef) Error!void {
    try self.writer.print("\nfunction _enc{s}(v: {s}): void {{\n", .{ name, name });
    try self.writer.writeAll("  switch (v.tag) {\n");
    for (def.variants) |v| {
        try self.writer.print("    case \"{s}\":\n", .{v.name});
        if (v.payload) |payload| {
            try self.writer.print("      _eTagHdr({d});\n      ", .{v.tag});
            try self.emitEncodeExpr(payload, "(v as any).value");
            try self.writer.writeAll(";\n");
        } else {
            try self.writer.print("      _eUvar({d}n);\n", .{v.tag});
        }
        try self.writer.writeAll("      break;\n");
    }
    try self.writer.writeAll("  }\n}\n");
    try self.writer.print("\nexport function encode{s}(value: {s}): Uint8Array {{\n", .{ name, name });
    try self.writer.print("  _reset();\n  _enc{s}(value);\n  return _finish();\n}}\n", .{name});
}

fn emitEncodeExpr(self: *TsGen, ty: Ast.TypeExpr, access: []const u8) Error!void {
    switch (ty) {
        .bool => try self.writer.print("_eBool({s})", .{access}),
        .string => try self.writer.print("_eStr({s})", .{access}),
        .bytes => try self.writer.print("_eBytes({s})", .{access}),
        .int => |i| {
            switch (i.kind) {
                .uvar => if (self.varint_as_number) {
                    try self.writer.print("_eUvar(BigInt({s}))", .{access});
                } else {
                    try self.writer.print("_eUvar({s})", .{access});
                },
                .ivar => if (self.varint_as_number) {
                    try self.writer.print("_eIvar(BigInt({s}))", .{access});
                } else {
                    try self.writer.print("_eIvar({s})", .{access});
                },
                else => {
                    const fn_name = switch (i.kind) {
                        .u8 => "_eU8",
                        .u16 => "_eU16",
                        .u32 => "_eU32",
                        .u64 => "_eU64",
                        .i8 => "_eI8",
                        .i16 => "_eI16",
                        .i32 => "_eI32",
                        .i64 => "_eI64",
                        else => unreachable,
                    };
                    try self.writer.print("{s}({s})", .{ fn_name, access });
                },
            }
        },
        .float => |f| {
            const fn_name = switch (f.kind) {
                .f16 => "_eF16",
                .f32 => "_eF32",
                .f64 => "_eF64",
            };
            try self.writer.print("{s}({s})", .{ fn_name, access });
        },
        .option => |o| {
            if (isMultiStatementEncode(o.child)) {
                try self.writer.print("({s}) === null ? _wb(0x00) : (() => {{ _eTagHdr(1); ", .{access});
                try self.emitEncodeExpr(o.child, access);
                try self.writer.writeAll("; })()");
            } else {
                try self.writer.print("({s}) === null ? _wb(0x00) : (_eTagHdr(1), ", .{access});
                try self.emitEncodeExpr(o.child, access);
                try self.writer.writeAll(")");
            }
        },
        .array => |a| {
            const lv = try std.fmt.allocPrint(self.arena, "_i{d}", .{self.loop_depth});
            self.loop_depth += 1;
            switch (a.*) {
                .variable => |v| {
                    try self.writer.print("_eArrHdr(({s}).length)", .{access});
                    try self.writer.print(";\n  for (let {s} = 0; {s} < ({s}).length; {s}++) {{ ", .{ lv, lv, access, lv });
                    const elem_access = try std.fmt.allocPrint(self.arena, "({s})[{s}]", .{ access, lv });
                    try self.emitEncodeExpr(v.element, elem_access);
                    try self.writer.writeAll("; }");
                },
                .fixed => |f| {
                    try self.writer.print("_eArrHdr({d})", .{f.len});
                    try self.writer.print(";\n  for (let {s} = 0; {s} < {d}; {s}++) {{ ", .{ lv, lv, f.len, lv });
                    const elem_access = try std.fmt.allocPrint(self.arena, "({s})[{s}]", .{ access, lv });
                    try self.emitEncodeExpr(f.element, elem_access);
                    try self.writer.writeAll("; }");
                },
                .external_len => |e| {
                    try self.writer.writeAll("_wb(0x9f)");
                    try self.writer.print(";\n  for (let {s} = 0; {s} < ({s}).length; {s}++) {{ ", .{ lv, lv, access, lv });
                    const elem_access = try std.fmt.allocPrint(self.arena, "({s})[{s}]", .{ access, lv });
                    try self.emitEncodeExpr(e.element, elem_access);
                    try self.writer.writeAll("; }\n  _wb(0xff)");
                },
            }
            self.loop_depth -= 1;
        },
        .struct_ => |s| {
            if (self.inline_struct_names.get(s)) |sname| {
                try self.writer.print("_enc{s}({s})", .{ sname, access });
            }
        },
        .enum_ => |e| {
            if (self.inline_enum_names.get(e)) |ename| {
                try self.writer.print("_enc{s}({s})", .{ ename, access });
            }
        },
        .union_ => |u| {
            if (self.inline_union_names.get(u)) |uname| {
                try self.writer.print("_enc{s}({s})", .{ uname, access });
            }
        },
        .named => |n| {
            try self.writer.print("_enc{s}({s})", .{ n.name, access });
        },
        .qualified => |q| {
            if (self.resolveQualified(q.namespace, q.name)) |_| {
                try self.writer.print("_enc{s}({s})", .{ q.name, access });
            } else {
                try self.writer.print("undefined as any /* TODO: encode {s}.{s} */", .{ q.namespace, q.name });
            }
        },
    }
}

// =========================================================================
// Decoders
// =========================================================================

fn emitDecoderForDef(self: *TsGen, def: Ast.TypeDef) Error!void {
    switch (def.ty) {
        .struct_ => |s| try self.emitStructDecoder(def.name, s),
        .enum_ => |e| try self.emitEnumDecoder(def.name, e),
        .union_ => |u| try self.emitUnionDecoder(def.name, u),
        else => {
            // Type alias — generate internal + public decoder
            try self.writer.print("\nfunction _dec{s}(): {s} {{ return ", .{ def.name, def.name });
            try self.emitDecodeExpr(def.ty);
            try self.writer.writeAll("; }\n");
            try self.writer.print("\nexport function decode{s}(data: Uint8Array): {s} {{\n", .{ def.name, def.name });
            try self.writer.print("  _dInit(data);\n  return _dec{s}();\n}}\n", .{def.name});
        },
    }
}

fn emitStructDecoder(self: *TsGen, name: []const u8, def: *const Ast.StructDef) Error!void {
    try self.writer.print("\nfunction _dec{s}(): {s} {{\n", .{ name, name });
    try self.writer.writeAll("  const _al = _dArrHdr();\n");

    if (def.fields.len == 0) {
        try self.writer.writeAll("  for (let _i = 0; _i < _al; _i++) _dSkip();\n");
        try self.writer.writeAll("  return {};\n}\n");
    } else {
        const max_rank = self.maxRank(def);

        for (def.fields) |field| {
            const fname = try self.sanitizeFieldName(field.name);
            try self.writer.print("  let _{s}: ", .{fname});
            try self.emitTypeRef(field.ty);
            if (field.ty == .option) {
                try self.writer.writeAll(" = null;\n");
            } else {
                try self.writer.writeAll(" = undefined!;\n");
            }
        }

        var rank: u64 = 0;
        while (rank <= max_rank) : (rank += 1) {
            try self.writer.print("  if (_al > {d}) ", .{rank});
            if (self.findFieldByRank(def, rank)) |field| {
                const fname = try self.sanitizeFieldName(field.name);
                try self.writer.print("_{s} = ", .{fname});
                try self.emitDecodeExpr(field.ty);
                try self.writer.writeAll(";\n");
            } else {
                try self.writer.writeAll("_dSkip();\n");
            }
        }

        try self.writer.print("  for (let _i = {d}; _i < _al; _i++) _dSkip();\n", .{max_rank + 1});

        try self.writer.writeAll("  return { ");
        for (def.fields, 0..) |field, idx| {
            const fname = try self.sanitizeFieldName(field.name);
            try self.writer.print("{s}: _{s}", .{ fname, fname });
            if (idx < def.fields.len - 1) try self.writer.writeAll(", ");
        }
        try self.writer.writeAll(" };\n}\n");
    }

    try self.writer.print("\nexport function decode{s}(data: Uint8Array): {s} {{\n", .{ name, name });
    try self.writer.print("  _dInit(data);\n  return _dec{s}();\n}}\n", .{name});
}

fn emitEnumDecoder(self: *TsGen, name: []const u8, def: *const Ast.EnumDef) Error!void {
    _ = def;
    try self.writer.print("\nfunction _dec{s}(): {s} {{ return Number(_dUvar()) as {s}; }}\n", .{ name, name, name });
    try self.writer.print("\nexport function decode{s}(data: Uint8Array): {s} {{\n", .{ name, name });
    try self.writer.print("  _dInit(data);\n  return _dec{s}();\n}}\n", .{name});
}

fn emitUnionDecoder(self: *TsGen, name: []const u8, def: *const Ast.UnionDef) Error!void {
    try self.writer.print("\nfunction _dec{s}(): {s} {{\n", .{ name, name });
    try self.writer.writeAll("  const _b = _rb();\n");
    try self.writer.writeAll("  const _maj = _b >> 5;\n");

    try self.writer.writeAll("  if (_maj === 6) {\n");
    try self.writer.writeAll("    const _ai = _b & 0x1f;\n");
    try self.writer.writeAll("    let _tag: number;\n");
    try self.writer.writeAll("    if (_ai <= 23) _tag = _ai;\n");
    try self.writer.writeAll("    else if (_ai === 24) _tag = _rb();\n");
    try self.writer.writeAll("    else if (_ai === 25) _tag = _r16();\n");
    try self.writer.writeAll("    else if (_ai === 26) _tag = _r32();\n");
    try self.writer.writeAll("    else throw new Error(\"unsupported tag size\");\n");
    try self.writer.writeAll("    switch (_tag) {\n");
    for (def.variants) |v| {
        if (v.payload) |payload| {
            try self.writer.print("      case {d}: return {{ tag: \"{s}\" as const, value: ", .{ v.tag, v.name });
            try self.emitDecodeExpr(payload);
            try self.writer.writeAll(" };\n");
        }
    }
    try self.writer.writeAll("      default: throw new Error(\"unknown union tag \" + _tag);\n");
    try self.writer.writeAll("    }\n");
    try self.writer.writeAll("  }\n");

    try self.writer.writeAll("  if (_maj === 0) {\n");
    try self.writer.writeAll("    const _ai = _b & 0x1f;\n");
    try self.writer.writeAll("    let _tag: number;\n");
    try self.writer.writeAll("    if (_ai <= 23) _tag = _ai;\n");
    try self.writer.writeAll("    else if (_ai === 24) _tag = _rb();\n");
    try self.writer.writeAll("    else if (_ai === 25) _tag = _r16();\n");
    try self.writer.writeAll("    else if (_ai === 26) _tag = _r32();\n");
    try self.writer.writeAll("    else throw new Error(\"unsupported tag size\");\n");
    try self.writer.writeAll("    switch (_tag) {\n");
    for (def.variants) |v| {
        if (v.payload == null) {
            try self.writer.print("      case {d}: return {{ tag: \"{s}\" as const }};\n", .{ v.tag, v.name });
        }
    }
    try self.writer.writeAll("      default: throw new Error(\"unknown union tag \" + _tag);\n");
    try self.writer.writeAll("    }\n");
    try self.writer.writeAll("  }\n");

    try self.writer.print("  throw new Error(\"expected union {s}\");\n", .{name});
    try self.writer.writeAll("}\n");
    try self.writer.print("\nexport function decode{s}(data: Uint8Array): {s} {{\n", .{ name, name });
    try self.writer.print("  _dInit(data);\n  return _dec{s}();\n}}\n", .{name});
}

fn emitDecodeExpr(self: *TsGen, ty: Ast.TypeExpr) Error!void {
    switch (ty) {
        .bool => try self.writer.writeAll("_dBool()"),
        .string => try self.writer.writeAll("_dStr()"),
        .bytes => try self.writer.writeAll("_dBytes()"),
        .int => |i| {
            switch (i.kind) {
                .uvar => try self.writer.writeAll(if (self.varint_as_number) "Number(_dUvar())" else "_dUvar()"),
                .ivar => try self.writer.writeAll(if (self.varint_as_number) "Number(_dIvar())" else "_dIvar()"),
                else => {
                    const fn_name = switch (i.kind) {
                        .u8 => "_dU8()",
                        .u16 => "_dU16()",
                        .u32 => "_dU32()",
                        .u64 => "_dU64()",
                        .i8 => "_dI8()",
                        .i16 => "_dI16()",
                        .i32 => "_dI32()",
                        .i64 => "_dI64()",
                        else => unreachable,
                    };
                    try self.writer.writeAll(fn_name);
                },
            }
        },
        .float => |f| {
            const fn_name = switch (f.kind) {
                .f16 => "_dF16()",
                .f32 => "_dF32()",
                .f64 => "_dF64()",
            };
            try self.writer.writeAll(fn_name);
        },
        .option => |o| {
            try self.writer.writeAll("(_rb() === 0x00 ? null : (");
            try self.emitDecodeExpr(o.child);
            try self.writer.writeAll("))");
        },
        .array => |a| switch (a.*) {
            .variable => |v| {
                try self.writer.writeAll("(() => { const _n = _dArrHdr(); const _a: ");
                try self.emitTypeRef(v.element);
                try self.writer.writeAll("[] = []; for (let _i = 0; _i < _n; _i++) _a.push(");
                try self.emitDecodeExpr(v.element);
                try self.writer.writeAll("); return _a; })()");
            },
            .fixed => |f| {
                try self.writer.writeAll("(() => { const _n = _dArrHdr(); const _a: ");
                try self.emitTypeRef(f.element);
                try self.writer.print("[] = []; for (let _i = 0; _i < {d}; _i++) _a.push(", .{f.len});
                try self.emitDecodeExpr(f.element);
                try self.writer.writeAll("); return _a; })()");
            },
            .external_len => |e| {
                try self.writer.writeAll("(() => { if (_rb() !== 0x9f) throw new Error(\"expected indefinite array\"); const _a: ");
                try self.emitTypeRef(e.element);
                try self.writer.writeAll("[] = []; while (_dPeek() !== 0xff) _a.push(");
                try self.emitDecodeExpr(e.element);
                try self.writer.writeAll("); _dAdv(); return _a; })()");
            },
        },
        .struct_ => |s| {
            if (self.inline_struct_names.get(s)) |sname| {
                try self.writer.print("_dec{s}()", .{sname});
            }
        },
        .enum_ => |e| {
            if (self.inline_enum_names.get(e)) |ename| {
                try self.writer.print("_dec{s}()", .{ename});
            }
        },
        .union_ => |u| {
            if (self.inline_union_names.get(u)) |uname| {
                try self.writer.print("_dec{s}()", .{uname});
            }
        },
        .named => |n| {
            try self.writer.print("_dec{s}()", .{n.name});
        },
        .qualified => |q| {
            if (self.resolveQualified(q.namespace, q.name)) |_| {
                try self.writer.print("_dec{s}()", .{q.name});
            } else {
                try self.writer.print("undefined as any /* TODO: decode {s}.{s} */", .{ q.namespace, q.name });
            }
        },
    }
}

// =========================================================================
// Helpers
// =========================================================================

fn maxRank(self: *TsGen, def: *const Ast.StructDef) u64 {
    _ = self;
    var max: u64 = 0;
    for (def.fields) |field| {
        if (field.rank > max) max = field.rank;
    }
    return if (def.fields.len == 0) 0 else max;
}

fn findFieldByRank(self: *TsGen, def: *const Ast.StructDef, rank: u64) ?Ast.FieldDef {
    _ = self;
    for (def.fields) |field| {
        if (field.rank == rank) return field;
    }
    return null;
}

fn isMultiStatementEncode(ty: Ast.TypeExpr) bool {
    return switch (ty) {
        .array => true,
        .option => |o| isMultiStatementEncode(o.child),
        else => false,
    };
}

fn sanitizeFieldName(self: *TsGen, name: []const u8) Error![]const u8 {
    if (name.len > 0 and std.ascii.isDigit(name[0])) {
        return try std.fmt.allocPrint(self.arena, "_{s}", .{name});
    }
    return name;
}

/// Look up a qualified type reference in imported schemas.
fn resolveQualified(self: *TsGen, namespace: []const u8, name: []const u8) ?Ast.TypeDef {
    const imported_schema = self.imports.get(namespace) orelse return null;
    for (imported_schema.definitions) |def| {
        if (std.mem.eql(u8, def.name, name)) return def;
    }
    return null;
}
