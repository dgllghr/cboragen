// Generated by cboragen â€” do not edit

// === Runtime ===

const _te = new TextEncoder();
const _td = new TextDecoder();

// --- Encoder state ---
let _b = new Uint8Array(256);
let _v = new DataView(_b.buffer);
let _p = 0;

function _grow(n: number): void {
  if (_p + n <= _b.length) return;
  let c = _b.length;
  while (c < _p + n) c *= 2;
  const nb = new Uint8Array(c);
  nb.set(_b);
  _b = nb;
  _v = new DataView(_b.buffer);
}

function _wb(byte: number): void { _grow(1); _b[_p++] = byte; }
function _w16(val: number): void { _grow(2); _v.setUint16(_p, val); _p += 2; }
function _w32(val: number): void { _grow(4); _v.setUint32(_p, val); _p += 4; }
function _w64(val: bigint): void { _grow(8); _v.setBigUint64(_p, val); _p += 8; }

function _eMajLen(base: number, n: number | bigint): void {
  const v = typeof n === "bigint" ? n : BigInt(n);
  if (v <= 23n) { _wb(base | Number(v)); }
  else if (v <= 0xffn) { _wb(base | 24); _wb(Number(v)); }
  else if (v <= 0xffffn) { _wb(base | 25); _w16(Number(v)); }
  else if (v <= 0xffffffffn) { _wb(base | 26); _w32(Number(v)); }
  else { _wb(base | 27); _w64(v); }
}

function _eBool(v: boolean): void { _wb(v ? 0xf5 : 0xf4); }
function _eNull(): void { _wb(0xf6); }

function _eU8(v: number): void { _wb(0x18); _wb(v); }
function _eU16(v: number): void { _wb(0x19); _w16(v); }
function _eU32(v: number): void { _wb(0x1a); _w32(v); }
function _eU64(v: bigint): void { _wb(0x1b); _w64(v); }

function _eI8(v: number): void {
  if (v >= 0) { _wb(0x18); _wb(v); }
  else { _wb(0x38); _wb(-1 - v); }
}
function _eI16(v: number): void {
  if (v >= 0) { _wb(0x19); _w16(v); }
  else { _wb(0x39); _w16(-1 - v); }
}
function _eI32(v: number): void {
  if (v >= 0) { _wb(0x1a); _w32(v); }
  else { _wb(0x3a); _w32(-1 - v); }
}
function _eI64(v: bigint): void {
  if (v >= 0n) { _wb(0x1b); _w64(v); }
  else { _wb(0x3b); _w64(-1n - v); }
}

function _eUvar(v: bigint): void { _eMajLen(0x00, v); }
function _eIvar(v: bigint): void {
  if (v >= 0n) { _eMajLen(0x00, v); }
  else { _eMajLen(0x20, -1n - v); }
}

function _eF16(v: number): void { _wb(0xf9); _grow(2); _v.setFloat16(_p, v); _p += 2; }
function _eF32(v: number): void { _wb(0xfa); _grow(4); _v.setFloat32(_p, v); _p += 4; }
function _eF64(v: number): void { _wb(0xfb); _grow(8); _v.setFloat64(_p, v); _p += 8; }

function _eStr(v: string): void {
  const enc = _te.encode(v);
  _eMajLen(0x60, enc.length);
  _grow(enc.length);
  _b.set(enc, _p);
  _p += enc.length;
}

function _eBytes(v: Uint8Array): void {
  _eMajLen(0x40, v.length);
  _grow(v.length);
  _b.set(v, _p);
  _p += v.length;
}

function _eArrHdr(len: number): void { _eMajLen(0x80, len); }
function _eTagHdr(tag: number): void { _eMajLen(0xc0, tag); }

function _reset(): void { _p = 0; }
function _finish(): Uint8Array { const r = _b.slice(0, _p); _p = 0; return r; }

// --- Decoder state ---
let _db: Uint8Array;
let _dv: DataView;
let _dp: number;

function _dInit(data: Uint8Array): void {
  _db = data; _dv = new DataView(data.buffer, data.byteOffset, data.byteLength); _dp = 0;
}

function _rb(): number { return _db[_dp++]; }
function _r16(): number { const v = _dv.getUint16(_dp); _dp += 2; return v; }
function _r32(): number { const v = _dv.getUint32(_dp); _dp += 4; return v; }
function _r64(): bigint { const v = _dv.getBigUint64(_dp); _dp += 8; return v; }

function _dBool(): boolean {
  const b = _rb();
  if (b === 0xf5) return true;
  if (b === 0xf4) return false;
  throw new Error("expected bool");
}

function _dU8(): number { if (_rb() !== 0x18) throw new Error("expected u8"); return _rb(); }
function _dU16(): number { if (_rb() !== 0x19) throw new Error("expected u16"); return _r16(); }
function _dU32(): number { if (_rb() !== 0x1a) throw new Error("expected u32"); return _r32(); }
function _dU64(): bigint { if (_rb() !== 0x1b) throw new Error("expected u64"); return _r64(); }

function _dI8(): number {
  const b = _rb();
  if (b === 0x18) return _rb();
  if (b === 0x38) return -1 - _rb();
  throw new Error("expected i8");
}
function _dI16(): number {
  const b = _rb();
  if (b === 0x19) return _r16();
  if (b === 0x39) return -1 - _r16();
  throw new Error("expected i16");
}
function _dI32(): number {
  const b = _rb();
  if (b === 0x1a) return _r32();
  if (b === 0x3a) return -1 - _r32();
  throw new Error("expected i32");
}
function _dI64(): bigint {
  const b = _rb();
  if (b === 0x1b) return _r64();
  if (b === 0x3b) return -1n - _r64();
  throw new Error("expected i64");
}

function _dMajLen(expectedMajor: number): number {
  const b = _rb();
  const maj = b >> 5;
  if (maj !== expectedMajor) throw new Error("unexpected major type " + maj);
  const ai = b & 0x1f;
  if (ai <= 23) return ai;
  if (ai === 24) return _rb();
  if (ai === 25) return _r16();
  if (ai === 26) return _r32();
  if (ai === 27) return Number(_r64());
  throw new Error("unsupported additional info " + ai);
}

function _dUvar(): bigint {
  const b = _rb();
  const ai = b & 0x1f;
  if (ai <= 23) return BigInt(ai);
  if (ai === 24) return BigInt(_rb());
  if (ai === 25) return BigInt(_r16());
  if (ai === 26) return BigInt(_r32());
  if (ai === 27) return _r64();
  throw new Error("expected uvarint");
}

function _dIvar(): bigint {
  const b = _rb();
  const maj = b >> 5;
  const ai = b & 0x1f;
  let v: bigint;
  if (ai <= 23) v = BigInt(ai);
  else if (ai === 24) v = BigInt(_rb());
  else if (ai === 25) v = BigInt(_r16());
  else if (ai === 26) v = BigInt(_r32());
  else if (ai === 27) v = _r64();
  else throw new Error("expected ivarint");
  if (maj === 0) return v;
  if (maj === 1) return -1n - v;
  throw new Error("expected ivarint");
}

function _dF16(): number { if (_rb() !== 0xf9) throw new Error("expected f16"); const v = _dv.getFloat16(_dp); _dp += 2; return v; }
function _dF32(): number { if (_rb() !== 0xfa) throw new Error("expected f32"); const v = _dv.getFloat32(_dp); _dp += 4; return v; }
function _dF64(): number { if (_rb() !== 0xfb) throw new Error("expected f64"); const v = _dv.getFloat64(_dp); _dp += 8; return v; }

function _dStr(): string {
  const len = _dMajLen(3);
  const s = _td.decode(_db.subarray(_dp, _dp + len));
  _dp += len;
  return s;
}

function _dBytes(): Uint8Array {
  const len = _dMajLen(2);
  const b = _db.slice(_dp, _dp + len);
  _dp += len;
  return b;
}

function _dArrHdr(): number { return _dMajLen(4); }

function _dSkip(): void {
  const b = _rb();
  const maj = b >> 5;
  const ai = b & 0x1f;
  if (maj === 7) {
    // simple/float
    if (ai <= 23) return;
    if (ai === 24) { _dp += 1; return; }
    if (ai === 25) { _dp += 2; return; }
    if (ai === 26) { _dp += 4; return; }
    if (ai === 27) { _dp += 8; return; }
    return;
  }
  let len: number;
  if (ai <= 23) len = ai;
  else if (ai === 24) len = _rb();
  else if (ai === 25) len = _r16();
  else if (ai === 26) len = _r32();
  else if (ai === 27) len = Number(_r64());
  else if (ai === 31) {
    // indefinite length
    while (_db[_dp] !== 0xff) _dSkip();
    _dp++; // consume break
    return;
  }
  else throw new Error("unsupported AI in skip");
  if (maj === 0 || maj === 1) return; // integer, value already consumed
  if (maj === 2 || maj === 3) { _dp += len; return; } // bytes/string
  if (maj === 4) { for (let i = 0; i < len; i++) _dSkip(); return; } // array
  if (maj === 5) { for (let i = 0; i < len * 2; i++) _dSkip(); return; } // map
  if (maj === 6) { _dSkip(); return; } // tag: skip the wrapped item
}


// === Types ===

export interface Shape_rect {
  w: number;
  h: number;
}

/** All primitive types in one struct */
export interface Primitives {
  b: boolean;
  u8v: number;
  u16v: number;
  u32v: number;
  u64v: bigint;
  i8v: number;
  i16v: number;
  i32v: number;
  i64v: bigint;
  f32v: number;
  f64v: number;
  uvar: bigint;
  ivar: bigint;
  str: string;
  bin: Uint8Array;
}

/** Struct with optional fields */
export interface WithOptionals {
  required: string;
  maybe: number | null;
  maybeStr: string | null;
}

/** Simple enum */
export const Color = {
  Red: 0,
  Green: 1,
  Blue: 2,
} as const;
export type Color = (typeof Color)[keyof typeof Color];

/** Union with unit and payload variants */
export type Shape =
  | { tag: "circle"; value: number }
  | { tag: "rect"; value: Shape_rect }
  | { tag: "point" }
;

/** Variable-length array wrapper */
export interface Numbers {
  values: number[];
}

/** Fixed-length array wrapper */
export interface Vec3 {
  xyz: number[];
}

/** External-length array wrapper */
export interface TimeSeries {
  count: number;
  timestamps: bigint[];
  values: number[];
}

/** Named type references */
export interface ColoredShape {
  color: Color;
  shape: Shape;
}

/** Type alias */
export type Id = bigint;

/** Struct referencing an alias */
export interface Entity {
  id: Id;
  name: string;
}

/** Nested arrays */
export interface Matrix {
  rows: number[][];
}

/** Struct with gaps in ranks */
export interface Sparse {
  first: number;
  second: string;
  third: boolean;
}


// === Encoders ===

function _encShape_rect(v: Shape_rect): void {
  _eArrHdr(2);
  _eF64(v.w);
  _eF64(v.h);
}

export function encodeShape_rect(value: Shape_rect): Uint8Array {
  _reset();
  _encShape_rect(value);
  return _finish();
}

function _encPrimitives(v: Primitives): void {
  _eArrHdr(15);
  _eBool(v.b);
  _eU8(v.u8v);
  _eU16(v.u16v);
  _eU32(v.u32v);
  _eU64(v.u64v);
  _eI8(v.i8v);
  _eI16(v.i16v);
  _eI32(v.i32v);
  _eI64(v.i64v);
  _eF32(v.f32v);
  _eF64(v.f64v);
  _eUvar(v.uvar);
  _eIvar(v.ivar);
  _eStr(v.str);
  _eBytes(v.bin);
}

export function encodePrimitives(value: Primitives): Uint8Array {
  _reset();
  _encPrimitives(value);
  return _finish();
}

function _encWithOptionals(v: WithOptionals): void {
  _eArrHdr(3);
  _eStr(v.required);
  (v.maybe) === null ? _wb(0x00) : (_eTagHdr(1), _eU32(v.maybe));
  (v.maybeStr) === null ? _wb(0x00) : (_eTagHdr(1), _eStr(v.maybeStr));
}

export function encodeWithOptionals(value: WithOptionals): Uint8Array {
  _reset();
  _encWithOptionals(value);
  return _finish();
}

function _encColor(v: Color): void { _eUvar(BigInt(v)); }

export function encodeColor(value: Color): Uint8Array {
  _reset();
  _encColor(value);
  return _finish();
}

function _encShape(v: Shape): void {
  switch (v.tag) {
    case "circle":
      _eTagHdr(0);
      _eF64((v as any).value);
      break;
    case "rect":
      _eTagHdr(1);
      _encShape_rect((v as any).value);
      break;
    case "point":
      _eUvar(2n);
      break;
  }
}

export function encodeShape(value: Shape): Uint8Array {
  _reset();
  _encShape(value);
  return _finish();
}

function _encNumbers(v: Numbers): void {
  _eArrHdr(1);
  _eArrHdr((v.values).length);
  for (let _i0 = 0; _i0 < (v.values).length; _i0++) { _eI32((v.values)[_i0]); };
}

export function encodeNumbers(value: Numbers): Uint8Array {
  _reset();
  _encNumbers(value);
  return _finish();
}

function _encVec3(v: Vec3): void {
  _eArrHdr(1);
  _eArrHdr(3);
  for (let _i0 = 0; _i0 < 3; _i0++) { _eF64((v.xyz)[_i0]); };
}

export function encodeVec3(value: Vec3): Uint8Array {
  _reset();
  _encVec3(value);
  return _finish();
}

function _encTimeSeries(v: TimeSeries): void {
  _eArrHdr(3);
  _eU32(v.count);
  _wb(0x9f);
  for (let _i0 = 0; _i0 < (v.timestamps).length; _i0++) { _eI64((v.timestamps)[_i0]); }
  _wb(0xff);
  _wb(0x9f);
  for (let _i0 = 0; _i0 < (v.values).length; _i0++) { _eF64((v.values)[_i0]); }
  _wb(0xff);
}

export function encodeTimeSeries(value: TimeSeries): Uint8Array {
  _reset();
  _encTimeSeries(value);
  return _finish();
}

function _encColoredShape(v: ColoredShape): void {
  _eArrHdr(2);
  _encColor(v.color);
  _encShape(v.shape);
}

export function encodeColoredShape(value: ColoredShape): Uint8Array {
  _reset();
  _encColoredShape(value);
  return _finish();
}

function _encId(v: Id): void { _eU64(v); }

export function encodeId(value: Id): Uint8Array {
  _reset();
  _encId(value);
  return _finish();
}

function _encEntity(v: Entity): void {
  _eArrHdr(2);
  _encId(v.id);
  _eStr(v.name);
}

export function encodeEntity(value: Entity): Uint8Array {
  _reset();
  _encEntity(value);
  return _finish();
}

function _encMatrix(v: Matrix): void {
  _eArrHdr(1);
  _eArrHdr((v.rows).length);
  for (let _i0 = 0; _i0 < (v.rows).length; _i0++) { _eArrHdr(((v.rows)[_i0]).length);
  for (let _i1 = 0; _i1 < ((v.rows)[_i0]).length; _i1++) { _eF64(((v.rows)[_i0])[_i1]); }; };
}

export function encodeMatrix(value: Matrix): Uint8Array {
  _reset();
  _encMatrix(value);
  return _finish();
}

function _encSparse(v: Sparse): void {
  _eArrHdr(11);
  _eU32(v.first);
  _eNull();
  _eNull();
  _eNull();
  _eNull();
  _eStr(v.second);
  _eNull();
  _eNull();
  _eNull();
  _eNull();
  _eBool(v.third);
}

export function encodeSparse(value: Sparse): Uint8Array {
  _reset();
  _encSparse(value);
  return _finish();
}

// === Decoders ===

function _decShape_rect(): Shape_rect {
  const _al = _dArrHdr();
  let _w: number = undefined!;
  let _h: number = undefined!;
  if (_al > 0) _w = _dF64();
  if (_al > 1) _h = _dF64();
  for (let _i = 2; _i < _al; _i++) _dSkip();
  return { w: _w, h: _h };
}

export function decodeShape_rect(data: Uint8Array): Shape_rect {
  _dInit(data);
  return _decShape_rect();
}

function _decPrimitives(): Primitives {
  const _al = _dArrHdr();
  let _b: boolean = undefined!;
  let _u8v: number = undefined!;
  let _u16v: number = undefined!;
  let _u32v: number = undefined!;
  let _u64v: bigint = undefined!;
  let _i8v: number = undefined!;
  let _i16v: number = undefined!;
  let _i32v: number = undefined!;
  let _i64v: bigint = undefined!;
  let _f32v: number = undefined!;
  let _f64v: number = undefined!;
  let _uvar: bigint = undefined!;
  let _ivar: bigint = undefined!;
  let _str: string = undefined!;
  let _bin: Uint8Array = undefined!;
  if (_al > 0) _b = _dBool();
  if (_al > 1) _u8v = _dU8();
  if (_al > 2) _u16v = _dU16();
  if (_al > 3) _u32v = _dU32();
  if (_al > 4) _u64v = _dU64();
  if (_al > 5) _i8v = _dI8();
  if (_al > 6) _i16v = _dI16();
  if (_al > 7) _i32v = _dI32();
  if (_al > 8) _i64v = _dI64();
  if (_al > 9) _f32v = _dF32();
  if (_al > 10) _f64v = _dF64();
  if (_al > 11) _uvar = _dUvar();
  if (_al > 12) _ivar = _dIvar();
  if (_al > 13) _str = _dStr();
  if (_al > 14) _bin = _dBytes();
  for (let _i = 15; _i < _al; _i++) _dSkip();
  return { b: _b, u8v: _u8v, u16v: _u16v, u32v: _u32v, u64v: _u64v, i8v: _i8v, i16v: _i16v, i32v: _i32v, i64v: _i64v, f32v: _f32v, f64v: _f64v, uvar: _uvar, ivar: _ivar, str: _str, bin: _bin };
}

export function decodePrimitives(data: Uint8Array): Primitives {
  _dInit(data);
  return _decPrimitives();
}

function _decWithOptionals(): WithOptionals {
  const _al = _dArrHdr();
  let _required: string = undefined!;
  let _maybe: number | null = null;
  let _maybeStr: string | null = null;
  if (_al > 0) _required = _dStr();
  if (_al > 1) _maybe = (_rb() === 0x00 ? null : (_dU32()));
  if (_al > 2) _maybeStr = (_rb() === 0x00 ? null : (_dStr()));
  for (let _i = 3; _i < _al; _i++) _dSkip();
  return { required: _required, maybe: _maybe, maybeStr: _maybeStr };
}

export function decodeWithOptionals(data: Uint8Array): WithOptionals {
  _dInit(data);
  return _decWithOptionals();
}

function _decColor(): Color { return Number(_dUvar()) as Color; }

export function decodeColor(data: Uint8Array): Color {
  _dInit(data);
  return _decColor();
}

function _decShape(): Shape {
  const _b = _rb();
  const _maj = _b >> 5;
  if (_maj === 6) {
    const _ai = _b & 0x1f;
    let _tag: number;
    if (_ai <= 23) _tag = _ai;
    else if (_ai === 24) _tag = _rb();
    else if (_ai === 25) _tag = _r16();
    else if (_ai === 26) _tag = _r32();
    else throw new Error("unsupported tag size");
    switch (_tag) {
      case 0: return { tag: "circle" as const, value: _dF64() };
      case 1: return { tag: "rect" as const, value: _decShape_rect() };
      default: throw new Error("unknown union tag " + _tag);
    }
  }
  if (_maj === 0) {
    const _ai = _b & 0x1f;
    let _tag: number;
    if (_ai <= 23) _tag = _ai;
    else if (_ai === 24) _tag = _rb();
    else if (_ai === 25) _tag = _r16();
    else if (_ai === 26) _tag = _r32();
    else throw new Error("unsupported tag size");
    switch (_tag) {
      case 2: return { tag: "point" as const };
      default: throw new Error("unknown union tag " + _tag);
    }
  }
  throw new Error("expected union Shape");
}

export function decodeShape(data: Uint8Array): Shape {
  _dInit(data);
  return _decShape();
}

function _decNumbers(): Numbers {
  const _al = _dArrHdr();
  let _values: number[] = undefined!;
  if (_al > 0) _values = (() => { const _n = _dArrHdr(); const _a: number[] = []; for (let _i = 0; _i < _n; _i++) _a.push(_dI32()); return _a; })();
  for (let _i = 1; _i < _al; _i++) _dSkip();
  return { values: _values };
}

export function decodeNumbers(data: Uint8Array): Numbers {
  _dInit(data);
  return _decNumbers();
}

function _decVec3(): Vec3 {
  const _al = _dArrHdr();
  let _xyz: number[] = undefined!;
  if (_al > 0) _xyz = (() => { const _n = _dArrHdr(); const _a: number[] = []; for (let _i = 0; _i < 3; _i++) _a.push(_dF64()); return _a; })();
  for (let _i = 1; _i < _al; _i++) _dSkip();
  return { xyz: _xyz };
}

export function decodeVec3(data: Uint8Array): Vec3 {
  _dInit(data);
  return _decVec3();
}

function _decTimeSeries(): TimeSeries {
  const _al = _dArrHdr();
  let _count: number = undefined!;
  let _timestamps: bigint[] = undefined!;
  let _values: number[] = undefined!;
  if (_al > 0) _count = _dU32();
  if (_al > 1) _timestamps = (() => { if (_rb() !== 0x9f) throw new Error("expected indefinite array"); const _a: bigint[] = []; while (_db[_dp] !== 0xff) _a.push(_dI64()); _dp++; return _a; })();
  if (_al > 2) _values = (() => { if (_rb() !== 0x9f) throw new Error("expected indefinite array"); const _a: number[] = []; while (_db[_dp] !== 0xff) _a.push(_dF64()); _dp++; return _a; })();
  for (let _i = 3; _i < _al; _i++) _dSkip();
  return { count: _count, timestamps: _timestamps, values: _values };
}

export function decodeTimeSeries(data: Uint8Array): TimeSeries {
  _dInit(data);
  return _decTimeSeries();
}

function _decColoredShape(): ColoredShape {
  const _al = _dArrHdr();
  let _color: Color = undefined!;
  let _shape: Shape = undefined!;
  if (_al > 0) _color = _decColor();
  if (_al > 1) _shape = _decShape();
  for (let _i = 2; _i < _al; _i++) _dSkip();
  return { color: _color, shape: _shape };
}

export function decodeColoredShape(data: Uint8Array): ColoredShape {
  _dInit(data);
  return _decColoredShape();
}

function _decId(): Id { return _dU64(); }

export function decodeId(data: Uint8Array): Id {
  _dInit(data);
  return _decId();
}

function _decEntity(): Entity {
  const _al = _dArrHdr();
  let _id: Id = undefined!;
  let _name: string = undefined!;
  if (_al > 0) _id = _decId();
  if (_al > 1) _name = _dStr();
  for (let _i = 2; _i < _al; _i++) _dSkip();
  return { id: _id, name: _name };
}

export function decodeEntity(data: Uint8Array): Entity {
  _dInit(data);
  return _decEntity();
}

function _decMatrix(): Matrix {
  const _al = _dArrHdr();
  let _rows: number[][] = undefined!;
  if (_al > 0) _rows = (() => { const _n = _dArrHdr(); const _a: number[][] = []; for (let _i = 0; _i < _n; _i++) _a.push((() => { const _n = _dArrHdr(); const _a: number[] = []; for (let _i = 0; _i < _n; _i++) _a.push(_dF64()); return _a; })()); return _a; })();
  for (let _i = 1; _i < _al; _i++) _dSkip();
  return { rows: _rows };
}

export function decodeMatrix(data: Uint8Array): Matrix {
  _dInit(data);
  return _decMatrix();
}

function _decSparse(): Sparse {
  const _al = _dArrHdr();
  let _first: number = undefined!;
  let _second: string = undefined!;
  let _third: boolean = undefined!;
  if (_al > 0) _first = _dU32();
  if (_al > 1) _dSkip();
  if (_al > 2) _dSkip();
  if (_al > 3) _dSkip();
  if (_al > 4) _dSkip();
  if (_al > 5) _second = _dStr();
  if (_al > 6) _dSkip();
  if (_al > 7) _dSkip();
  if (_al > 8) _dSkip();
  if (_al > 9) _dSkip();
  if (_al > 10) _third = _dBool();
  for (let _i = 11; _i < _al; _i++) _dSkip();
  return { first: _first, second: _second, third: _third };
}

export function decodeSparse(data: Uint8Array): Sparse {
  _dInit(data);
  return _decSparse();
}
