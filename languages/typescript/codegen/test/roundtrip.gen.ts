// Generated by cboragen â€” do not edit

import { _reset, _finish, _wb, _eBool, _eNull, _eU8, _eU16, _eU32, _eU64, _eI8, _eI16, _eI32, _eI64, _eUvar, _eIvar, _eF16, _eF32, _eF64, _eStr, _eBytes, _eArrHdr, _eTagHdr, _dInit, _rb, _r16, _r32, _dBool, _dU8, _dU16, _dU32, _dU64, _dI8, _dI16, _dI32, _dI64, _dUvar, _dIvar, _dF16, _dF32, _dF64, _dStr, _dBytes, _dArrHdr, _dSkip, _dPeek, _dAdv } from "@cboragen/runtime";

// === Types ===

export interface Shape_rect {
  w: number;
  h: number;
}

/** All primitive types in one struct */
export interface Primitives {
  b: boolean;
  u8v: number;
  u16v: number;
  u32v: number;
  u64v: bigint;
  i8v: number;
  i16v: number;
  i32v: number;
  i64v: bigint;
  f32v: number;
  f64v: number;
  uvar: bigint;
  ivar: bigint;
  str: string;
  bin: Uint8Array;
}

/** Struct with optional fields */
export interface WithOptionals {
  required: string;
  maybe: number | null;
  maybeStr: string | null;
}

/** Simple enum */
export const Color = {
  Red: 0,
  Green: 1,
  Blue: 2,
} as const;
export type Color = (typeof Color)[keyof typeof Color];

/** Union with unit and payload variants */
export type Shape =
  | { tag: "circle"; value: number }
  | { tag: "rect"; value: Shape_rect }
  | { tag: "point" }
;

/** Variable-length array wrapper */
export interface Numbers {
  values: number[];
}

/** Fixed-length array wrapper */
export interface Vec3 {
  xyz: number[];
}

/** External-length array wrapper */
export interface TimeSeries {
  count: number;
  timestamps: bigint[];
  values: number[];
}

/** Named type references */
export interface ColoredShape {
  color: Color;
  shape: Shape;
}

/** Type alias */
export type Id = bigint;

/** Struct referencing an alias */
export interface Entity {
  id: Id;
  name: string;
}

/** Nested arrays */
export interface Matrix {
  rows: number[][];
}

/** Struct with gaps in ranks */
export interface Sparse {
  first: number;
  second: string;
  third: boolean;
}


// === Encoders ===

function _encShape_rect(v: Shape_rect): void {
  _eArrHdr(2);
  _eF64(v.w);
  _eF64(v.h);
}

export function encodeShape_rect(value: Shape_rect): Uint8Array {
  _reset();
  _encShape_rect(value);
  return _finish();
}

function _encPrimitives(v: Primitives): void {
  _eArrHdr(15);
  _eBool(v.b);
  _eU8(v.u8v);
  _eU16(v.u16v);
  _eU32(v.u32v);
  _eU64(v.u64v);
  _eI8(v.i8v);
  _eI16(v.i16v);
  _eI32(v.i32v);
  _eI64(v.i64v);
  _eF32(v.f32v);
  _eF64(v.f64v);
  _eUvar(v.uvar);
  _eIvar(v.ivar);
  _eStr(v.str);
  _eBytes(v.bin);
}

export function encodePrimitives(value: Primitives): Uint8Array {
  _reset();
  _encPrimitives(value);
  return _finish();
}

function _encWithOptionals(v: WithOptionals): void {
  _eArrHdr(3);
  _eStr(v.required);
  (v.maybe) === null ? _wb(0x00) : (_eTagHdr(1), _eU32(v.maybe));
  (v.maybeStr) === null ? _wb(0x00) : (_eTagHdr(1), _eStr(v.maybeStr));
}

export function encodeWithOptionals(value: WithOptionals): Uint8Array {
  _reset();
  _encWithOptionals(value);
  return _finish();
}

function _encColor(v: Color): void { _eUvar(BigInt(v)); }

export function encodeColor(value: Color): Uint8Array {
  _reset();
  _encColor(value);
  return _finish();
}

function _encShape(v: Shape): void {
  switch (v.tag) {
    case "circle":
      _eTagHdr(0);
      _eF64((v as any).value);
      break;
    case "rect":
      _eTagHdr(1);
      _encShape_rect((v as any).value);
      break;
    case "point":
      _eUvar(2n);
      break;
  }
}

export function encodeShape(value: Shape): Uint8Array {
  _reset();
  _encShape(value);
  return _finish();
}

function _encNumbers(v: Numbers): void {
  _eArrHdr(1);
  _eArrHdr((v.values).length);
  for (let _i0 = 0; _i0 < (v.values).length; _i0++) { _eI32((v.values)[_i0]); };
}

export function encodeNumbers(value: Numbers): Uint8Array {
  _reset();
  _encNumbers(value);
  return _finish();
}

function _encVec3(v: Vec3): void {
  _eArrHdr(1);
  _eArrHdr(3);
  for (let _i0 = 0; _i0 < 3; _i0++) { _eF64((v.xyz)[_i0]); };
}

export function encodeVec3(value: Vec3): Uint8Array {
  _reset();
  _encVec3(value);
  return _finish();
}

function _encTimeSeries(v: TimeSeries): void {
  _eArrHdr(3);
  _eU32(v.count);
  _wb(0x9f);
  for (let _i0 = 0; _i0 < (v.timestamps).length; _i0++) { _eI64((v.timestamps)[_i0]); }
  _wb(0xff);
  _wb(0x9f);
  for (let _i0 = 0; _i0 < (v.values).length; _i0++) { _eF64((v.values)[_i0]); }
  _wb(0xff);
}

export function encodeTimeSeries(value: TimeSeries): Uint8Array {
  _reset();
  _encTimeSeries(value);
  return _finish();
}

function _encColoredShape(v: ColoredShape): void {
  _eArrHdr(2);
  _encColor(v.color);
  _encShape(v.shape);
}

export function encodeColoredShape(value: ColoredShape): Uint8Array {
  _reset();
  _encColoredShape(value);
  return _finish();
}

function _encId(v: Id): void { _eU64(v); }

export function encodeId(value: Id): Uint8Array {
  _reset();
  _encId(value);
  return _finish();
}

function _encEntity(v: Entity): void {
  _eArrHdr(2);
  _encId(v.id);
  _eStr(v.name);
}

export function encodeEntity(value: Entity): Uint8Array {
  _reset();
  _encEntity(value);
  return _finish();
}

function _encMatrix(v: Matrix): void {
  _eArrHdr(1);
  _eArrHdr((v.rows).length);
  for (let _i0 = 0; _i0 < (v.rows).length; _i0++) { _eArrHdr(((v.rows)[_i0]).length);
  for (let _i1 = 0; _i1 < ((v.rows)[_i0]).length; _i1++) { _eF64(((v.rows)[_i0])[_i1]); }; };
}

export function encodeMatrix(value: Matrix): Uint8Array {
  _reset();
  _encMatrix(value);
  return _finish();
}

function _encSparse(v: Sparse): void {
  _eArrHdr(11);
  _eU32(v.first);
  _eNull();
  _eNull();
  _eNull();
  _eNull();
  _eStr(v.second);
  _eNull();
  _eNull();
  _eNull();
  _eNull();
  _eBool(v.third);
}

export function encodeSparse(value: Sparse): Uint8Array {
  _reset();
  _encSparse(value);
  return _finish();
}

// === Decoders ===

function _decShape_rect(): Shape_rect {
  const _al = _dArrHdr();
  let _w: number = undefined!;
  let _h: number = undefined!;
  if (_al > 0) _w = _dF64();
  if (_al > 1) _h = _dF64();
  for (let _i = 2; _i < _al; _i++) _dSkip();
  return { w: _w, h: _h };
}

export function decodeShape_rect(data: Uint8Array): Shape_rect {
  _dInit(data);
  return _decShape_rect();
}

function _decPrimitives(): Primitives {
  const _al = _dArrHdr();
  let _b: boolean = undefined!;
  let _u8v: number = undefined!;
  let _u16v: number = undefined!;
  let _u32v: number = undefined!;
  let _u64v: bigint = undefined!;
  let _i8v: number = undefined!;
  let _i16v: number = undefined!;
  let _i32v: number = undefined!;
  let _i64v: bigint = undefined!;
  let _f32v: number = undefined!;
  let _f64v: number = undefined!;
  let _uvar: bigint = undefined!;
  let _ivar: bigint = undefined!;
  let _str: string = undefined!;
  let _bin: Uint8Array = undefined!;
  if (_al > 0) _b = _dBool();
  if (_al > 1) _u8v = _dU8();
  if (_al > 2) _u16v = _dU16();
  if (_al > 3) _u32v = _dU32();
  if (_al > 4) _u64v = _dU64();
  if (_al > 5) _i8v = _dI8();
  if (_al > 6) _i16v = _dI16();
  if (_al > 7) _i32v = _dI32();
  if (_al > 8) _i64v = _dI64();
  if (_al > 9) _f32v = _dF32();
  if (_al > 10) _f64v = _dF64();
  if (_al > 11) _uvar = _dUvar();
  if (_al > 12) _ivar = _dIvar();
  if (_al > 13) _str = _dStr();
  if (_al > 14) _bin = _dBytes();
  for (let _i = 15; _i < _al; _i++) _dSkip();
  return { b: _b, u8v: _u8v, u16v: _u16v, u32v: _u32v, u64v: _u64v, i8v: _i8v, i16v: _i16v, i32v: _i32v, i64v: _i64v, f32v: _f32v, f64v: _f64v, uvar: _uvar, ivar: _ivar, str: _str, bin: _bin };
}

export function decodePrimitives(data: Uint8Array): Primitives {
  _dInit(data);
  return _decPrimitives();
}

function _decWithOptionals(): WithOptionals {
  const _al = _dArrHdr();
  let _required: string = undefined!;
  let _maybe: number | null = null;
  let _maybeStr: string | null = null;
  if (_al > 0) _required = _dStr();
  if (_al > 1) _maybe = (_rb() === 0x00 ? null : (_dU32()));
  if (_al > 2) _maybeStr = (_rb() === 0x00 ? null : (_dStr()));
  for (let _i = 3; _i < _al; _i++) _dSkip();
  return { required: _required, maybe: _maybe, maybeStr: _maybeStr };
}

export function decodeWithOptionals(data: Uint8Array): WithOptionals {
  _dInit(data);
  return _decWithOptionals();
}

function _decColor(): Color { return Number(_dUvar()) as Color; }

export function decodeColor(data: Uint8Array): Color {
  _dInit(data);
  return _decColor();
}

function _decShape(): Shape {
  const _b = _rb();
  const _maj = _b >> 5;
  if (_maj === 6) {
    const _ai = _b & 0x1f;
    let _tag: number;
    if (_ai <= 23) _tag = _ai;
    else if (_ai === 24) _tag = _rb();
    else if (_ai === 25) _tag = _r16();
    else if (_ai === 26) _tag = _r32();
    else throw new Error("unsupported tag size");
    switch (_tag) {
      case 0: return { tag: "circle" as const, value: _dF64() };
      case 1: return { tag: "rect" as const, value: _decShape_rect() };
      default: throw new Error("unknown union tag " + _tag);
    }
  }
  if (_maj === 0) {
    const _ai = _b & 0x1f;
    let _tag: number;
    if (_ai <= 23) _tag = _ai;
    else if (_ai === 24) _tag = _rb();
    else if (_ai === 25) _tag = _r16();
    else if (_ai === 26) _tag = _r32();
    else throw new Error("unsupported tag size");
    switch (_tag) {
      case 2: return { tag: "point" as const };
      default: throw new Error("unknown union tag " + _tag);
    }
  }
  throw new Error("expected union Shape");
}

export function decodeShape(data: Uint8Array): Shape {
  _dInit(data);
  return _decShape();
}

function _decNumbers(): Numbers {
  const _al = _dArrHdr();
  let _values: number[] = undefined!;
  if (_al > 0) _values = (() => { const _n = _dArrHdr(); const _a: number[] = []; for (let _i = 0; _i < _n; _i++) _a.push(_dI32()); return _a; })();
  for (let _i = 1; _i < _al; _i++) _dSkip();
  return { values: _values };
}

export function decodeNumbers(data: Uint8Array): Numbers {
  _dInit(data);
  return _decNumbers();
}

function _decVec3(): Vec3 {
  const _al = _dArrHdr();
  let _xyz: number[] = undefined!;
  if (_al > 0) _xyz = (() => { const _n = _dArrHdr(); const _a: number[] = []; for (let _i = 0; _i < 3; _i++) _a.push(_dF64()); return _a; })();
  for (let _i = 1; _i < _al; _i++) _dSkip();
  return { xyz: _xyz };
}

export function decodeVec3(data: Uint8Array): Vec3 {
  _dInit(data);
  return _decVec3();
}

function _decTimeSeries(): TimeSeries {
  const _al = _dArrHdr();
  let _count: number = undefined!;
  let _timestamps: bigint[] = undefined!;
  let _values: number[] = undefined!;
  if (_al > 0) _count = _dU32();
  if (_al > 1) _timestamps = (() => { if (_rb() !== 0x9f) throw new Error("expected indefinite array"); const _a: bigint[] = []; while (_dPeek() !== 0xff) _a.push(_dI64()); _dAdv(); return _a; })();
  if (_al > 2) _values = (() => { if (_rb() !== 0x9f) throw new Error("expected indefinite array"); const _a: number[] = []; while (_dPeek() !== 0xff) _a.push(_dF64()); _dAdv(); return _a; })();
  for (let _i = 3; _i < _al; _i++) _dSkip();
  return { count: _count, timestamps: _timestamps, values: _values };
}

export function decodeTimeSeries(data: Uint8Array): TimeSeries {
  _dInit(data);
  return _decTimeSeries();
}

function _decColoredShape(): ColoredShape {
  const _al = _dArrHdr();
  let _color: Color = undefined!;
  let _shape: Shape = undefined!;
  if (_al > 0) _color = _decColor();
  if (_al > 1) _shape = _decShape();
  for (let _i = 2; _i < _al; _i++) _dSkip();
  return { color: _color, shape: _shape };
}

export function decodeColoredShape(data: Uint8Array): ColoredShape {
  _dInit(data);
  return _decColoredShape();
}

function _decId(): Id { return _dU64(); }

export function decodeId(data: Uint8Array): Id {
  _dInit(data);
  return _decId();
}

function _decEntity(): Entity {
  const _al = _dArrHdr();
  let _id: Id = undefined!;
  let _name: string = undefined!;
  if (_al > 0) _id = _decId();
  if (_al > 1) _name = _dStr();
  for (let _i = 2; _i < _al; _i++) _dSkip();
  return { id: _id, name: _name };
}

export function decodeEntity(data: Uint8Array): Entity {
  _dInit(data);
  return _decEntity();
}

function _decMatrix(): Matrix {
  const _al = _dArrHdr();
  let _rows: number[][] = undefined!;
  if (_al > 0) _rows = (() => { const _n = _dArrHdr(); const _a: number[][] = []; for (let _i = 0; _i < _n; _i++) _a.push((() => { const _n = _dArrHdr(); const _a: number[] = []; for (let _i = 0; _i < _n; _i++) _a.push(_dF64()); return _a; })()); return _a; })();
  for (let _i = 1; _i < _al; _i++) _dSkip();
  return { rows: _rows };
}

export function decodeMatrix(data: Uint8Array): Matrix {
  _dInit(data);
  return _decMatrix();
}

function _decSparse(): Sparse {
  const _al = _dArrHdr();
  let _first: number = undefined!;
  let _second: string = undefined!;
  let _third: boolean = undefined!;
  if (_al > 0) _first = _dU32();
  if (_al > 1) _dSkip();
  if (_al > 2) _dSkip();
  if (_al > 3) _dSkip();
  if (_al > 4) _dSkip();
  if (_al > 5) _second = _dStr();
  if (_al > 6) _dSkip();
  if (_al > 7) _dSkip();
  if (_al > 8) _dSkip();
  if (_al > 9) _dSkip();
  if (_al > 10) _third = _dBool();
  for (let _i = 11; _i < _al; _i++) _dSkip();
  return { first: _first, second: _second, third: _third };
}

export function decodeSparse(data: Uint8Array): Sparse {
  _dInit(data);
  return _decSparse();
}
