// Generated by cboragen â€” do not edit

// === Runtime ===

const _te = new TextEncoder();
const _td = new TextDecoder();

// --- Encoder state ---
let _b = new Uint8Array(256);
let _v = new DataView(_b.buffer);
let _p = 0;

function _grow(n: number): void {
  if (_p + n <= _b.length) return;
  let c = _b.length;
  while (c < _p + n) c *= 2;
  const nb = new Uint8Array(c);
  nb.set(_b);
  _b = nb;
  _v = new DataView(_b.buffer);
}

function _wb(byte: number): void { _grow(1); _b[_p++] = byte; }
function _w16(val: number): void { _grow(2); _v.setUint16(_p, val); _p += 2; }
function _w32(val: number): void { _grow(4); _v.setUint32(_p, val); _p += 4; }
function _w64(val: bigint): void { _grow(8); _v.setBigUint64(_p, val); _p += 8; }

function _eMajLen(base: number, n: number | bigint): void {
  const v = typeof n === "bigint" ? n : BigInt(n);
  if (v <= 23n) { _wb(base | Number(v)); }
  else if (v <= 0xffn) { _wb(base | 24); _wb(Number(v)); }
  else if (v <= 0xffffn) { _wb(base | 25); _w16(Number(v)); }
  else if (v <= 0xffffffffn) { _wb(base | 26); _w32(Number(v)); }
  else { _wb(base | 27); _w64(v); }
}

function _eBool(v: boolean): void { _wb(v ? 0xf5 : 0xf4); }
function _eNull(): void { _wb(0xf6); }

function _eU8(v: number): void { _wb(0x18); _wb(v); }
function _eU16(v: number): void { _wb(0x19); _w16(v); }
function _eU32(v: number): void { _wb(0x1a); _w32(v); }
function _eU64(v: bigint): void { _wb(0x1b); _w64(v); }

function _eI8(v: number): void {
  if (v >= 0) { _wb(0x18); _wb(v); }
  else { _wb(0x38); _wb(-1 - v); }
}
function _eI16(v: number): void {
  if (v >= 0) { _wb(0x19); _w16(v); }
  else { _wb(0x39); _w16(-1 - v); }
}
function _eI32(v: number): void {
  if (v >= 0) { _wb(0x1a); _w32(v); }
  else { _wb(0x3a); _w32(-1 - v); }
}
function _eI64(v: bigint): void {
  if (v >= 0n) { _wb(0x1b); _w64(v); }
  else { _wb(0x3b); _w64(-1n - v); }
}

function _eUvar(v: bigint): void { _eMajLen(0x00, v); }
function _eIvar(v: bigint): void {
  if (v >= 0n) { _eMajLen(0x00, v); }
  else { _eMajLen(0x20, -1n - v); }
}

function _eF16(v: number): void { _wb(0xf9); _grow(2); _v.setFloat16(_p, v); _p += 2; }
function _eF32(v: number): void { _wb(0xfa); _grow(4); _v.setFloat32(_p, v); _p += 4; }
function _eF64(v: number): void { _wb(0xfb); _grow(8); _v.setFloat64(_p, v); _p += 8; }

function _eStr(v: string): void {
  const enc = _te.encode(v);
  _eMajLen(0x60, enc.length);
  _grow(enc.length);
  _b.set(enc, _p);
  _p += enc.length;
}

function _eBytes(v: Uint8Array): void {
  _eMajLen(0x40, v.length);
  _grow(v.length);
  _b.set(v, _p);
  _p += v.length;
}

function _eArrHdr(len: number): void { _eMajLen(0x80, len); }
function _eTagHdr(tag: number): void { _eMajLen(0xc0, tag); }

function _reset(): void { _p = 0; }
function _finish(): Uint8Array { const r = _b.slice(0, _p); _p = 0; return r; }

// --- Decoder state ---
let _db: Uint8Array;
let _dv: DataView;
let _dp: number;

function _dInit(data: Uint8Array): void {
  _db = data; _dv = new DataView(data.buffer, data.byteOffset, data.byteLength); _dp = 0;
}

function _rb(): number { return _db[_dp++]; }
function _r16(): number { const v = _dv.getUint16(_dp); _dp += 2; return v; }
function _r32(): number { const v = _dv.getUint32(_dp); _dp += 4; return v; }
function _r64(): bigint { const v = _dv.getBigUint64(_dp); _dp += 8; return v; }

function _dBool(): boolean {
  const b = _rb();
  if (b === 0xf5) return true;
  if (b === 0xf4) return false;
  throw new Error("expected bool");
}

function _dU8(): number { if (_rb() !== 0x18) throw new Error("expected u8"); return _rb(); }
function _dU16(): number { if (_rb() !== 0x19) throw new Error("expected u16"); return _r16(); }
function _dU32(): number { if (_rb() !== 0x1a) throw new Error("expected u32"); return _r32(); }
function _dU64(): bigint { if (_rb() !== 0x1b) throw new Error("expected u64"); return _r64(); }

function _dI8(): number {
  const b = _rb();
  if (b === 0x18) return _rb();
  if (b === 0x38) return -1 - _rb();
  throw new Error("expected i8");
}
function _dI16(): number {
  const b = _rb();
  if (b === 0x19) return _r16();
  if (b === 0x39) return -1 - _r16();
  throw new Error("expected i16");
}
function _dI32(): number {
  const b = _rb();
  if (b === 0x1a) return _r32();
  if (b === 0x3a) return -1 - _r32();
  throw new Error("expected i32");
}
function _dI64(): bigint {
  const b = _rb();
  if (b === 0x1b) return _r64();
  if (b === 0x3b) return -1n - _r64();
  throw new Error("expected i64");
}

function _dMajLen(expectedMajor: number): number {
  const b = _rb();
  const maj = b >> 5;
  if (maj !== expectedMajor) throw new Error("unexpected major type " + maj);
  const ai = b & 0x1f;
  if (ai <= 23) return ai;
  if (ai === 24) return _rb();
  if (ai === 25) return _r16();
  if (ai === 26) return _r32();
  if (ai === 27) return Number(_r64());
  throw new Error("unsupported additional info " + ai);
}

function _dUvar(): bigint {
  const b = _rb();
  const ai = b & 0x1f;
  if (ai <= 23) return BigInt(ai);
  if (ai === 24) return BigInt(_rb());
  if (ai === 25) return BigInt(_r16());
  if (ai === 26) return BigInt(_r32());
  if (ai === 27) return _r64();
  throw new Error("expected uvarint");
}

function _dIvar(): bigint {
  const b = _rb();
  const maj = b >> 5;
  const ai = b & 0x1f;
  let v: bigint;
  if (ai <= 23) v = BigInt(ai);
  else if (ai === 24) v = BigInt(_rb());
  else if (ai === 25) v = BigInt(_r16());
  else if (ai === 26) v = BigInt(_r32());
  else if (ai === 27) v = _r64();
  else throw new Error("expected ivarint");
  if (maj === 0) return v;
  if (maj === 1) return -1n - v;
  throw new Error("expected ivarint");
}

function _dF16(): number { if (_rb() !== 0xf9) throw new Error("expected f16"); const v = _dv.getFloat16(_dp); _dp += 2; return v; }
function _dF32(): number { if (_rb() !== 0xfa) throw new Error("expected f32"); const v = _dv.getFloat32(_dp); _dp += 4; return v; }
function _dF64(): number { if (_rb() !== 0xfb) throw new Error("expected f64"); const v = _dv.getFloat64(_dp); _dp += 8; return v; }

function _dStr(): string {
  const len = _dMajLen(3);
  const s = _td.decode(_db.subarray(_dp, _dp + len));
  _dp += len;
  return s;
}

function _dBytes(): Uint8Array {
  const len = _dMajLen(2);
  const b = _db.slice(_dp, _dp + len);
  _dp += len;
  return b;
}

function _dArrHdr(): number { return _dMajLen(4); }

function _dSkip(): void {
  const b = _rb();
  const maj = b >> 5;
  const ai = b & 0x1f;
  if (maj === 7) {
    // simple/float
    if (ai <= 23) return;
    if (ai === 24) { _dp += 1; return; }
    if (ai === 25) { _dp += 2; return; }
    if (ai === 26) { _dp += 4; return; }
    if (ai === 27) { _dp += 8; return; }
    return;
  }
  let len: number;
  if (ai <= 23) len = ai;
  else if (ai === 24) len = _rb();
  else if (ai === 25) len = _r16();
  else if (ai === 26) len = _r32();
  else if (ai === 27) len = Number(_r64());
  else if (ai === 31) {
    // indefinite length
    while (_db[_dp] !== 0xff) _dSkip();
    _dp++; // consume break
    return;
  }
  else throw new Error("unsupported AI in skip");
  if (maj === 0 || maj === 1) return; // integer, value already consumed
  if (maj === 2 || maj === 3) { _dp += len; return; } // bytes/string
  if (maj === 4) { for (let i = 0; i < len; i++) _dSkip(); return; } // array
  if (maj === 5) { for (let i = 0; i < len * 2; i++) _dSkip(); return; } // map
  if (maj === 6) { _dSkip(); return; } // tag: skip the wrapped item
}


// === Types ===

/** A 3D point for micro-benchmarks */
export interface Point3D {
  x: number;
  y: number;
  z: number;
}

/** A user profile with various field types */
export interface User {
  id: bigint;
  username: string;
  email: string;
  age: number;
  active: boolean;
  score: number;
  tags: string[];
  metadata: UserMetadata | null;
}

export interface UserMetadata {
  createdAt: bigint;
  lastLogin: bigint;
  loginCount: number;
  preferences: Preferences;
}

export interface Preferences {
  theme: Theme;
  notifications: boolean;
  language: string;
}

export const Theme = {
  Light: 0,
  Dark: 1,
  System: 2,
} as const;
export type Theme = (typeof Theme)[keyof typeof Theme];

/** A complex nested structure */
export interface Message {
  id: bigint;
  sender: User;
  recipients: User[];
  subject: string;
  body: string;
  attachments: Attachment[];
  priority: Priority;
  timestamp: bigint;
}

export interface Attachment {
  name: string;
  mimeType: string;
  size: number;
  data: Uint8Array;
}

export const Priority = {
  Low: 0,
  Normal: 1,
  High: 2,
  Urgent: 3,
} as const;
export type Priority = (typeof Priority)[keyof typeof Priority];

/** Array of points for batch operations */
export interface PointCloud {
  points: Point3D[];
  name: string;
}

/** Float array for numeric benchmarks */
export interface Numbers {
  values: number[];
  label: string;
}


// === Encoders ===

function _encPoint3D(v: Point3D): void {
  _eArrHdr(3);
  _eF64(v.x);
  _eF64(v.y);
  _eF64(v.z);
}

export function encodePoint3D(value: Point3D): Uint8Array {
  _reset();
  _encPoint3D(value);
  return _finish();
}

function _encUser(v: User): void {
  _eArrHdr(8);
  _eU64(v.id);
  _eStr(v.username);
  _eStr(v.email);
  _eU8(v.age);
  _eBool(v.active);
  _eF64(v.score);
  _eArrHdr((v.tags).length);
  for (let _i0 = 0; _i0 < (v.tags).length; _i0++) { _eStr((v.tags)[_i0]); };
  (v.metadata) === null ? _wb(0x00) : (_eTagHdr(1), _encUserMetadata(v.metadata));
}

export function encodeUser(value: User): Uint8Array {
  _reset();
  _encUser(value);
  return _finish();
}

function _encUserMetadata(v: UserMetadata): void {
  _eArrHdr(4);
  _eU64(v.createdAt);
  _eU64(v.lastLogin);
  _eU32(v.loginCount);
  _encPreferences(v.preferences);
}

export function encodeUserMetadata(value: UserMetadata): Uint8Array {
  _reset();
  _encUserMetadata(value);
  return _finish();
}

function _encPreferences(v: Preferences): void {
  _eArrHdr(3);
  _encTheme(v.theme);
  _eBool(v.notifications);
  _eStr(v.language);
}

export function encodePreferences(value: Preferences): Uint8Array {
  _reset();
  _encPreferences(value);
  return _finish();
}

function _encTheme(v: Theme): void { _eUvar(BigInt(v)); }

export function encodeTheme(value: Theme): Uint8Array {
  _reset();
  _encTheme(value);
  return _finish();
}

function _encMessage(v: Message): void {
  _eArrHdr(8);
  _eU64(v.id);
  _encUser(v.sender);
  _eArrHdr((v.recipients).length);
  for (let _i0 = 0; _i0 < (v.recipients).length; _i0++) { _encUser((v.recipients)[_i0]); };
  _eStr(v.subject);
  _eStr(v.body);
  _eArrHdr((v.attachments).length);
  for (let _i0 = 0; _i0 < (v.attachments).length; _i0++) { _encAttachment((v.attachments)[_i0]); };
  _encPriority(v.priority);
  _eU64(v.timestamp);
}

export function encodeMessage(value: Message): Uint8Array {
  _reset();
  _encMessage(value);
  return _finish();
}

function _encAttachment(v: Attachment): void {
  _eArrHdr(4);
  _eStr(v.name);
  _eStr(v.mimeType);
  _eU32(v.size);
  _eBytes(v.data);
}

export function encodeAttachment(value: Attachment): Uint8Array {
  _reset();
  _encAttachment(value);
  return _finish();
}

function _encPriority(v: Priority): void { _eUvar(BigInt(v)); }

export function encodePriority(value: Priority): Uint8Array {
  _reset();
  _encPriority(value);
  return _finish();
}

function _encPointCloud(v: PointCloud): void {
  _eArrHdr(2);
  _eArrHdr((v.points).length);
  for (let _i0 = 0; _i0 < (v.points).length; _i0++) { _encPoint3D((v.points)[_i0]); };
  _eStr(v.name);
}

export function encodePointCloud(value: PointCloud): Uint8Array {
  _reset();
  _encPointCloud(value);
  return _finish();
}

function _encNumbers(v: Numbers): void {
  _eArrHdr(2);
  _eArrHdr((v.values).length);
  for (let _i0 = 0; _i0 < (v.values).length; _i0++) { _eF64((v.values)[_i0]); };
  _eStr(v.label);
}

export function encodeNumbers(value: Numbers): Uint8Array {
  _reset();
  _encNumbers(value);
  return _finish();
}

// === Decoders ===

function _decPoint3D(): Point3D {
  const _al = _dArrHdr();
  let _x: number = undefined!;
  let _y: number = undefined!;
  let _z: number = undefined!;
  if (_al > 0) _x = _dF64();
  if (_al > 1) _y = _dF64();
  if (_al > 2) _z = _dF64();
  for (let _i = 3; _i < _al; _i++) _dSkip();
  return { x: _x, y: _y, z: _z };
}

export function decodePoint3D(data: Uint8Array): Point3D {
  _dInit(data);
  return _decPoint3D();
}

function _decUser(): User {
  const _al = _dArrHdr();
  let _id: bigint = undefined!;
  let _username: string = undefined!;
  let _email: string = undefined!;
  let _age: number = undefined!;
  let _active: boolean = undefined!;
  let _score: number = undefined!;
  let _tags: string[] = undefined!;
  let _metadata: UserMetadata | null = null;
  if (_al > 0) _id = _dU64();
  if (_al > 1) _username = _dStr();
  if (_al > 2) _email = _dStr();
  if (_al > 3) _age = _dU8();
  if (_al > 4) _active = _dBool();
  if (_al > 5) _score = _dF64();
  if (_al > 6) _tags = (() => { const _n = _dArrHdr(); const _a: string[] = []; for (let _i = 0; _i < _n; _i++) _a.push(_dStr()); return _a; })();
  if (_al > 7) _metadata = (_rb() === 0x00 ? null : (_decUserMetadata()));
  for (let _i = 8; _i < _al; _i++) _dSkip();
  return { id: _id, username: _username, email: _email, age: _age, active: _active, score: _score, tags: _tags, metadata: _metadata };
}

export function decodeUser(data: Uint8Array): User {
  _dInit(data);
  return _decUser();
}

function _decUserMetadata(): UserMetadata {
  const _al = _dArrHdr();
  let _createdAt: bigint = undefined!;
  let _lastLogin: bigint = undefined!;
  let _loginCount: number = undefined!;
  let _preferences: Preferences = undefined!;
  if (_al > 0) _createdAt = _dU64();
  if (_al > 1) _lastLogin = _dU64();
  if (_al > 2) _loginCount = _dU32();
  if (_al > 3) _preferences = _decPreferences();
  for (let _i = 4; _i < _al; _i++) _dSkip();
  return { createdAt: _createdAt, lastLogin: _lastLogin, loginCount: _loginCount, preferences: _preferences };
}

export function decodeUserMetadata(data: Uint8Array): UserMetadata {
  _dInit(data);
  return _decUserMetadata();
}

function _decPreferences(): Preferences {
  const _al = _dArrHdr();
  let _theme: Theme = undefined!;
  let _notifications: boolean = undefined!;
  let _language: string = undefined!;
  if (_al > 0) _theme = _decTheme();
  if (_al > 1) _notifications = _dBool();
  if (_al > 2) _language = _dStr();
  for (let _i = 3; _i < _al; _i++) _dSkip();
  return { theme: _theme, notifications: _notifications, language: _language };
}

export function decodePreferences(data: Uint8Array): Preferences {
  _dInit(data);
  return _decPreferences();
}

function _decTheme(): Theme { return Number(_dUvar()) as Theme; }

export function decodeTheme(data: Uint8Array): Theme {
  _dInit(data);
  return _decTheme();
}

function _decMessage(): Message {
  const _al = _dArrHdr();
  let _id: bigint = undefined!;
  let _sender: User = undefined!;
  let _recipients: User[] = undefined!;
  let _subject: string = undefined!;
  let _body: string = undefined!;
  let _attachments: Attachment[] = undefined!;
  let _priority: Priority = undefined!;
  let _timestamp: bigint = undefined!;
  if (_al > 0) _id = _dU64();
  if (_al > 1) _sender = _decUser();
  if (_al > 2) _recipients = (() => { const _n = _dArrHdr(); const _a: User[] = []; for (let _i = 0; _i < _n; _i++) _a.push(_decUser()); return _a; })();
  if (_al > 3) _subject = _dStr();
  if (_al > 4) _body = _dStr();
  if (_al > 5) _attachments = (() => { const _n = _dArrHdr(); const _a: Attachment[] = []; for (let _i = 0; _i < _n; _i++) _a.push(_decAttachment()); return _a; })();
  if (_al > 6) _priority = _decPriority();
  if (_al > 7) _timestamp = _dU64();
  for (let _i = 8; _i < _al; _i++) _dSkip();
  return { id: _id, sender: _sender, recipients: _recipients, subject: _subject, body: _body, attachments: _attachments, priority: _priority, timestamp: _timestamp };
}

export function decodeMessage(data: Uint8Array): Message {
  _dInit(data);
  return _decMessage();
}

function _decAttachment(): Attachment {
  const _al = _dArrHdr();
  let _name: string = undefined!;
  let _mimeType: string = undefined!;
  let _size: number = undefined!;
  let _data: Uint8Array = undefined!;
  if (_al > 0) _name = _dStr();
  if (_al > 1) _mimeType = _dStr();
  if (_al > 2) _size = _dU32();
  if (_al > 3) _data = _dBytes();
  for (let _i = 4; _i < _al; _i++) _dSkip();
  return { name: _name, mimeType: _mimeType, size: _size, data: _data };
}

export function decodeAttachment(data: Uint8Array): Attachment {
  _dInit(data);
  return _decAttachment();
}

function _decPriority(): Priority { return Number(_dUvar()) as Priority; }

export function decodePriority(data: Uint8Array): Priority {
  _dInit(data);
  return _decPriority();
}

function _decPointCloud(): PointCloud {
  const _al = _dArrHdr();
  let _points: Point3D[] = undefined!;
  let _name: string = undefined!;
  if (_al > 0) _points = (() => { const _n = _dArrHdr(); const _a: Point3D[] = []; for (let _i = 0; _i < _n; _i++) _a.push(_decPoint3D()); return _a; })();
  if (_al > 1) _name = _dStr();
  for (let _i = 2; _i < _al; _i++) _dSkip();
  return { points: _points, name: _name };
}

export function decodePointCloud(data: Uint8Array): PointCloud {
  _dInit(data);
  return _decPointCloud();
}

function _decNumbers(): Numbers {
  const _al = _dArrHdr();
  let _values: number[] = undefined!;
  let _label: string = undefined!;
  if (_al > 0) _values = (() => { const _n = _dArrHdr(); const _a: number[] = []; for (let _i = 0; _i < _n; _i++) _a.push(_dF64()); return _a; })();
  if (_al > 1) _label = _dStr();
  for (let _i = 2; _i < _al; _i++) _dSkip();
  return { values: _values, label: _label };
}

export function decodeNumbers(data: Uint8Array): Numbers {
  _dInit(data);
  return _decNumbers();
}
