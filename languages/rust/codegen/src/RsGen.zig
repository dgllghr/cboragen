const std = @import("std");
const parser = @import("parser");
const Ast = parser.Ast;

const RsGen = @This();

writer: std.io.AnyWriter,
schema: Ast.Schema,
arena: std.mem.Allocator,
loop_depth: u32,

/// Namespace → Schema for imported schemas.
imports: std.StringHashMap(Ast.Schema),

/// Inline types discovered during pass 1, keyed by pointer identity.
inline_struct_names: std.AutoHashMap(*const Ast.StructDef, []const u8),
inline_enum_names: std.AutoHashMap(*const Ast.EnumDef, []const u8),
inline_union_names: std.AutoHashMap(*const Ast.UnionDef, []const u8),

/// Ordered list of inline types to emit (preserves discovery order).
inline_structs: std.ArrayList(InlineStruct),
inline_enums: std.ArrayList(InlineEnum),
inline_unions: std.ArrayList(InlineUnion),

const InlineStruct = struct { name: []const u8, def: *const Ast.StructDef };
const InlineEnum = struct { name: []const u8, def: *const Ast.EnumDef };
const InlineUnion = struct { name: []const u8, def: *const Ast.UnionDef };

pub fn init(
    writer: std.io.AnyWriter,
    schema: Ast.Schema,
    imports: std.StringHashMap(Ast.Schema),
    arena: std.mem.Allocator,
) RsGen {
    return .{
        .writer = writer,
        .schema = schema,
        .arena = arena,
        .loop_depth = 0,
        .imports = imports,
        .inline_struct_names = std.AutoHashMap(*const Ast.StructDef, []const u8).init(arena),
        .inline_enum_names = std.AutoHashMap(*const Ast.EnumDef, []const u8).init(arena),
        .inline_union_names = std.AutoHashMap(*const Ast.UnionDef, []const u8).init(arena),
        .inline_structs = .{},
        .inline_enums = .{},
        .inline_unions = .{},
    };
}

const Error = std.io.AnyWriter.Error || std.mem.Allocator.Error;

pub fn generate(self: *RsGen) Error!void {
    // Pass 1: collect inline types — imported schemas first, then main
    var import_it = self.imports.iterator();
    while (import_it.next()) |entry| {
        for (entry.value_ptr.definitions) |def| {
            try self.collectInlineTypes(def.name, def.ty);
        }
    }
    for (self.schema.definitions) |def| {
        try self.collectInlineTypes(def.name, def.ty);
    }

    // Pass 2: emit Rust
    try self.writer.writeAll("// Generated by cboragen — do not edit\n\n");
    try self.writer.writeAll("use cboragen_runtime::{Writer, Reader};\n");

    // Types
    try self.writer.writeAll("\n// === Types ===\n");
    // Inline types first
    for (self.inline_structs.items) |entry| {
        try self.emitStructType(entry.name, entry.def, null);
    }
    for (self.inline_enums.items) |entry| {
        try self.emitEnumType(entry.name, entry.def, null);
    }
    for (self.inline_unions.items) |entry| {
        try self.emitUnionType(entry.name, entry.def, null);
    }
    // Imported top-level types
    var import_it2 = self.imports.iterator();
    while (import_it2.next()) |entry| {
        for (entry.value_ptr.definitions) |def| {
            try self.emitTypeDef(def);
        }
    }
    // Main schema top-level types
    for (self.schema.definitions) |def| {
        try self.emitTypeDef(def);
    }

    // Encoders
    try self.writer.writeAll("\n// === Encoders ===\n");
    for (self.inline_structs.items) |entry| {
        try self.emitStructEncoder(entry.name, entry.def);
    }
    for (self.inline_enums.items) |entry| {
        try self.emitEnumEncoder(entry.name, entry.def);
    }
    for (self.inline_unions.items) |entry| {
        try self.emitUnionEncoder(entry.name, entry.def);
    }
    var import_it3 = self.imports.iterator();
    while (import_it3.next()) |entry| {
        for (entry.value_ptr.definitions) |def| {
            try self.emitEncoderForDef(def);
        }
    }
    for (self.schema.definitions) |def| {
        try self.emitEncoderForDef(def);
    }

    // Decoders
    try self.writer.writeAll("\n// === Decoders ===\n");
    for (self.inline_structs.items) |entry| {
        try self.emitStructDecoder(entry.name, entry.def);
    }
    for (self.inline_enums.items) |entry| {
        try self.emitEnumDecoder(entry.name, entry.def);
    }
    for (self.inline_unions.items) |entry| {
        try self.emitUnionDecoder(entry.name, entry.def);
    }
    var import_it4 = self.imports.iterator();
    while (import_it4.next()) |entry| {
        for (entry.value_ptr.definitions) |def| {
            try self.emitDecoderForDef(def);
        }
    }
    for (self.schema.definitions) |def| {
        try self.emitDecoderForDef(def);
    }

    // Impl blocks (encode/encode_with/decode/decode_with on each struct/enum/union)
    try self.writer.writeAll("\n// === Impl ===\n");
    for (self.inline_structs.items) |entry| {
        try self.emitImplBlock(entry.name);
    }
    for (self.inline_enums.items) |entry| {
        try self.emitImplBlock(entry.name);
    }
    for (self.inline_unions.items) |entry| {
        try self.emitImplBlock(entry.name);
    }
    var import_it5 = self.imports.iterator();
    while (import_it5.next()) |entry| {
        for (entry.value_ptr.definitions) |def| {
            switch (def.ty) {
                .struct_, .enum_, .union_ => try self.emitImplBlock(def.name),
                else => {},
            }
        }
    }
    for (self.schema.definitions) |def| {
        switch (def.ty) {
            .struct_, .enum_, .union_ => try self.emitImplBlock(def.name),
            else => {},
        }
    }
}

// =========================================================================
// Pass 1: Collect inline types
// =========================================================================

fn collectInlineTypes(self: *RsGen, parent_name: []const u8, ty: Ast.TypeExpr) Error!void {
    switch (ty) {
        .struct_ => |s| {
            for (s.fields) |field| {
                try self.collectInlineTypesField(parent_name, field);
            }
        },
        .enum_ => {},
        .union_ => |u| {
            for (u.variants) |v| {
                if (v.payload) |payload| {
                    try self.collectInlineTypesVariant(parent_name, v.name, payload);
                }
            }
        },
        .array => |a| {
            try self.collectInlineTypes(parent_name, a.getElement());
        },
        .option => |o| {
            try self.collectInlineTypes(parent_name, o.child);
        },
        else => {},
    }
}

fn collectInlineTypesField(self: *RsGen, parent_name: []const u8, field: Ast.FieldDef) Error!void {
    switch (field.ty) {
        .struct_ => |s| {
            const fname = try self.sanitizeFieldName(field.name);
            const name = try toPascalCase(self.arena, try std.fmt.allocPrint(self.arena, "{s}_{s}", .{ parent_name, fname }));
            try self.inline_struct_names.put(s, name);
            try self.inline_structs.append(self.arena, .{ .name = name, .def = s });
            for (s.fields) |f| {
                try self.collectInlineTypesField(name, f);
            }
        },
        .enum_ => |e| {
            const fname = try self.sanitizeFieldName(field.name);
            const name = try toPascalCase(self.arena, try std.fmt.allocPrint(self.arena, "{s}_{s}", .{ parent_name, fname }));
            try self.inline_enum_names.put(e, name);
            try self.inline_enums.append(self.arena, .{ .name = name, .def = e });
        },
        .union_ => |u| {
            const fname = try self.sanitizeFieldName(field.name);
            const name = try toPascalCase(self.arena, try std.fmt.allocPrint(self.arena, "{s}_{s}", .{ parent_name, fname }));
            try self.inline_union_names.put(u, name);
            try self.inline_unions.append(self.arena, .{ .name = name, .def = u });
            for (u.variants) |v| {
                if (v.payload) |payload| {
                    try self.collectInlineTypesVariant(name, v.name, payload);
                }
            }
        },
        .array => |a| {
            try self.collectInlineTypesElement(parent_name, field.name, a.getElement());
        },
        .option => |o| {
            try self.collectInlineTypesOption(parent_name, field.name, o.child);
        },
        else => {},
    }
}

fn collectInlineTypesElement(self: *RsGen, parent_name: []const u8, field_name: []const u8, ty: Ast.TypeExpr) Error!void {
    switch (ty) {
        .struct_ => |s| {
            const fn_name = try self.sanitizeFieldName(field_name);
            const name = try toPascalCase(self.arena, try std.fmt.allocPrint(self.arena, "{s}_{s}", .{ parent_name, fn_name }));
            if (!self.inline_struct_names.contains(s)) {
                try self.inline_struct_names.put(s, name);
                try self.inline_structs.append(self.arena, .{ .name = name, .def = s });
                for (s.fields) |f| {
                    try self.collectInlineTypesField(name, f);
                }
            }
        },
        .enum_ => |e| {
            const fn_name = try self.sanitizeFieldName(field_name);
            const name = try toPascalCase(self.arena, try std.fmt.allocPrint(self.arena, "{s}_{s}", .{ parent_name, fn_name }));
            if (!self.inline_enum_names.contains(e)) {
                try self.inline_enum_names.put(e, name);
                try self.inline_enums.append(self.arena, .{ .name = name, .def = e });
            }
        },
        .union_ => |u| {
            const fn_name = try self.sanitizeFieldName(field_name);
            const name = try toPascalCase(self.arena, try std.fmt.allocPrint(self.arena, "{s}_{s}", .{ parent_name, fn_name }));
            if (!self.inline_union_names.contains(u)) {
                try self.inline_union_names.put(u, name);
                try self.inline_unions.append(self.arena, .{ .name = name, .def = u });
                for (u.variants) |v| {
                    if (v.payload) |payload| {
                        try self.collectInlineTypesVariant(name, v.name, payload);
                    }
                }
            }
        },
        .array => |a| {
            try self.collectInlineTypesElement(parent_name, field_name, a.getElement());
        },
        .option => |o| {
            try self.collectInlineTypesOption(parent_name, field_name, o.child);
        },
        else => {},
    }
}

fn collectInlineTypesOption(self: *RsGen, parent_name: []const u8, field_name: []const u8, ty: Ast.TypeExpr) Error!void {
    switch (ty) {
        .option => |o| try self.collectInlineTypesOption(parent_name, field_name, o.child),
        else => try self.collectInlineTypesElement(parent_name, field_name, ty),
    }
}

fn collectInlineTypesVariant(self: *RsGen, parent_name: []const u8, variant_name: []const u8, ty: Ast.TypeExpr) Error!void {
    switch (ty) {
        .struct_ => |s| {
            const name = try toPascalCase(self.arena, try std.fmt.allocPrint(self.arena, "{s}_{s}", .{ parent_name, variant_name }));
            try self.inline_struct_names.put(s, name);
            try self.inline_structs.append(self.arena, .{ .name = name, .def = s });
            for (s.fields) |f| {
                try self.collectInlineTypesField(name, f);
            }
        },
        .enum_ => |e| {
            const name = try toPascalCase(self.arena, try std.fmt.allocPrint(self.arena, "{s}_{s}", .{ parent_name, variant_name }));
            try self.inline_enum_names.put(e, name);
            try self.inline_enums.append(self.arena, .{ .name = name, .def = e });
        },
        .union_ => |u| {
            const name = try toPascalCase(self.arena, try std.fmt.allocPrint(self.arena, "{s}_{s}", .{ parent_name, variant_name }));
            try self.inline_union_names.put(u, name);
            try self.inline_unions.append(self.arena, .{ .name = name, .def = u });
            for (u.variants) |v| {
                if (v.payload) |payload| {
                    try self.collectInlineTypesVariant(name, v.name, payload);
                }
            }
        },
        .array => |a| {
            try self.collectInlineTypesElement(parent_name, variant_name, a.getElement());
        },
        .option => |o| {
            try self.collectInlineTypesOption(parent_name, variant_name, o.child);
        },
        else => {},
    }
}

// =========================================================================
// Pass 2: Emit Rust types
// =========================================================================

fn emitTypeDef(self: *RsGen, def: Ast.TypeDef) Error!void {
    switch (def.ty) {
        .struct_ => |s| try self.emitStructType(def.name, s, def.doc),
        .enum_ => |e| try self.emitEnumType(def.name, e, def.doc),
        .union_ => |u| try self.emitUnionType(def.name, u, def.doc),
        else => {
            try self.emitDoc(def.doc);
            try self.writer.print("\npub type {s} = ", .{def.name});
            try self.emitTypeRef(def.ty);
            try self.writer.writeAll(";\n");
        },
    }
}

fn emitStructType(self: *RsGen, name: []const u8, def: *const Ast.StructDef, doc: ?[]const u8) Error!void {
    try self.emitDoc(doc);
    try self.writer.print("\n#[derive(Debug, Clone, PartialEq)]\npub struct {s} {{\n", .{name});
    for (def.fields) |field| {
        try self.emitDoc(field.doc);
        const fname = try self.toSnakeCase(field.name);
        const safe_name = try rustSafeIdent(self.arena, fname);
        try self.writer.print("    pub {s}: ", .{safe_name});
        try self.emitTypeRef(field.ty);
        try self.writer.writeAll(",\n");
    }
    try self.writer.writeAll("}\n");
}

fn emitEnumType(self: *RsGen, name: []const u8, def: *const Ast.EnumDef, doc: ?[]const u8) Error!void {
    try self.emitDoc(doc);
    // Check if all variants are Copy-able (unit enum)
    try self.writer.print("\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum {s} {{\n", .{name});
    for (def.variants) |v| {
        try self.emitDoc(v.doc);
        const vname = try toPascalCase(self.arena, v.name);
        try self.writer.print("    {s},\n", .{vname});
    }
    try self.writer.writeAll("}\n");
}

fn emitUnionType(self: *RsGen, name: []const u8, def: *const Ast.UnionDef, doc: ?[]const u8) Error!void {
    try self.emitDoc(doc);
    try self.writer.print("\n#[derive(Debug, Clone, PartialEq)]\npub enum {s} {{\n", .{name});
    for (def.variants) |v| {
        try self.emitDoc(v.doc);
        const vname = try toPascalCase(self.arena, v.name);
        if (v.payload) |payload| {
            try self.writer.print("    {s}(", .{vname});
            try self.emitTypeRef(payload);
            try self.writer.writeAll("),\n");
        } else {
            try self.writer.print("    {s},\n", .{vname});
        }
    }
    try self.writer.writeAll("}\n");
}

fn emitTypeRef(self: *RsGen, ty: Ast.TypeExpr) Error!void {
    switch (ty) {
        .bool => try self.writer.writeAll("bool"),
        .string => try self.writer.writeAll("String"),
        .int => |i| {
            const name = switch (i.kind) {
                .u8 => "u8",
                .u16 => "u16",
                .u32 => "u32",
                .u64 => "u64",
                .i8 => "i8",
                .i16 => "i16",
                .i32 => "i32",
                .i64 => "i64",
                .uvar => "u64",
                .ivar => "i64",
            };
            try self.writer.writeAll(name);
        },
        .float => |f| {
            const name = switch (f.kind) {
                .f16 => "f32",
                .f32 => "f32",
                .f64 => "f64",
            };
            try self.writer.writeAll(name);
        },
        .struct_ => |s| {
            if (self.inline_struct_names.get(s)) |name| {
                try self.writer.writeAll(name);
            } else {
                try self.writer.writeAll("() /* inline struct */");
            }
        },
        .enum_ => |e| {
            if (self.inline_enum_names.get(e)) |name| {
                try self.writer.writeAll(name);
            } else {
                try self.writer.writeAll("() /* inline enum */");
            }
        },
        .union_ => |u| {
            if (self.inline_union_names.get(u)) |name| {
                try self.writer.writeAll(name);
            } else {
                try self.writer.writeAll("() /* inline union */");
            }
        },
        .option => |o| {
            try self.writer.writeAll("Option<");
            try self.emitTypeRef(o.child);
            try self.writer.writeAll(">");
        },
        .array => |a| {
            if (isU8Array(a.getElement())) {
                try self.writer.writeAll("Vec<u8>");
            } else {
                try self.writer.writeAll("Vec<");
                try self.emitTypeRef(a.getElement());
                try self.writer.writeAll(">");
            }
        },
        .named => |n| {
            try self.writer.writeAll(n.name);
        },
        .qualified => |q| {
            if (self.resolveQualified(q.namespace, q.name)) |_| {
                try self.writer.writeAll(q.name);
            } else {
                try self.writer.print("() /* TODO: unresolved {s}.{s} */", .{ q.namespace, q.name });
            }
        },
    }
}

fn emitDoc(self: *RsGen, doc: ?[]const u8) Error!void {
    const text = doc orelse return;
    if (std.mem.indexOfScalar(u8, text, '\n')) |_| {
        var it = std.mem.splitScalar(u8, text, '\n');
        while (it.next()) |line| {
            try self.writer.print("/// {s}\n", .{line});
        }
    } else {
        try self.writer.print("/// {s}\n", .{text});
    }
}

// =========================================================================
// Encoders
// =========================================================================

fn emitEncoderForDef(self: *RsGen, def: Ast.TypeDef) Error!void {
    switch (def.ty) {
        .struct_ => |s| try self.emitStructEncoder(def.name, s),
        .enum_ => |e| try self.emitEnumEncoder(def.name, e),
        .union_ => |u| try self.emitUnionEncoder(def.name, u),
        else => {
            // Type alias
            const fn_name = try toSnakeCaseAlloc(self.arena, def.name);
            try self.writer.print("\nfn _enc_{s}(w: &mut Writer, v: &{s}) {{\n    ", .{ fn_name, def.name });
            try self.emitEncodeExpr(def.ty, "v", true);
            try self.writer.writeAll(";\n}\n");
            try self.writer.print("\npub fn encode_{s}(value: &{s}) -> Vec<u8> {{\n", .{ fn_name, def.name });
            try self.writer.print("    let mut w = Writer::new();\n    _enc_{s}(&mut w, value);\n    w.finish()\n}}\n", .{fn_name});
        },
    }
}

fn emitStructEncoder(self: *RsGen, name: []const u8, def: *const Ast.StructDef) Error!void {
    const fn_name = try toSnakeCaseAlloc(self.arena, name);
    try self.writer.print("\nfn _enc_{s}(w: &mut Writer, v: &{s}) {{\n", .{ fn_name, name });
    if (def.fields.len == 0) {
        try self.writer.writeAll("    w.write_array_header(0);\n");
    } else {
        const max_rank = maxRank(def);
        try self.writer.print("    w.write_array_header({d});\n", .{max_rank + 1});
        var rank: u64 = 0;
        while (rank <= max_rank) : (rank += 1) {
            if (findFieldByRank(def, rank)) |field| {
                const fname = try self.toSnakeCase(field.name);
                const safe_name = try rustSafeIdent(self.arena, fname);
                const access = try std.fmt.allocPrint(self.arena, "v.{s}", .{safe_name});
                try self.writer.writeAll("    ");
                try self.emitEncodeExpr(field.ty, access, false);
                try self.writer.writeAll(";\n");
            } else {
                try self.writer.writeAll("    w.write_null();\n");
            }
        }
    }
    try self.writer.writeAll("}\n");
}

fn emitEnumEncoder(self: *RsGen, name: []const u8, def: *const Ast.EnumDef) Error!void {
    const fn_name = try toSnakeCaseAlloc(self.arena, name);
    try self.writer.print("\nfn _enc_{s}(w: &mut Writer, v: &{s}) {{\n", .{ fn_name, name });
    try self.writer.writeAll("    match v {\n");
    for (def.variants) |v| {
        const vname = try toPascalCase(self.arena, v.name);
        try self.writer.print("        {s}::{s} => w.write_uvarint({d}),\n", .{ name, vname, v.tag });
    }
    try self.writer.writeAll("    }\n}\n");
}

fn emitUnionEncoder(self: *RsGen, name: []const u8, def: *const Ast.UnionDef) Error!void {
    const fn_name = try toSnakeCaseAlloc(self.arena, name);
    try self.writer.print("\nfn _enc_{s}(w: &mut Writer, v: &{s}) {{\n", .{ fn_name, name });
    try self.writer.writeAll("    match v {\n");
    for (def.variants) |v| {
        const vname = try toPascalCase(self.arena, v.name);
        if (v.payload) |payload| {
            try self.writer.print("        {s}::{s}(val) => {{\n", .{ name, vname });
            try self.writer.print("            w.write_tag_header({d});\n            ", .{v.tag});
            try self.emitEncodeExpr(payload, "val", true);
            try self.writer.writeAll(";\n        }\n");
        } else {
            try self.writer.print("        {s}::{s} => w.write_uvarint({d}),\n", .{ name, vname, v.tag });
        }
    }
    try self.writer.writeAll("    }\n}\n");
}

/// Emit an encode expression.
/// `is_ref` tracks whether `access` is already a reference (&T).
/// - struct fields (v.x): is_ref=false → need &v.x for non-Copy types
/// - match arm bindings (val): is_ref=true → already a reference
/// - loop vars (_item): is_ref=true → already a reference
fn emitEncodeExpr(self: *RsGen, ty: Ast.TypeExpr, access: []const u8, is_ref: bool) Error!void {
    switch (ty) {
        .bool => {
            if (is_ref) {
                try self.writer.print("w.write_bool(*{s})", .{access});
            } else {
                try self.writer.print("w.write_bool({s})", .{access});
            }
        },
        .string => {
            if (is_ref) {
                try self.writer.print("w.write_string({s})", .{access});
            } else {
                try self.writer.print("w.write_string(&{s})", .{access});
            }
        },
        .int => |i| {
            const deref = if (is_ref) "*" else "";
            switch (i.kind) {
                .uvar => try self.writer.print("w.write_uvarint({s}{s})", .{ deref, access }),
                .ivar => try self.writer.print("w.write_ivarint({s}{s})", .{ deref, access }),
                else => {
                    const fn_name = switch (i.kind) {
                        .u8 => "write_u8",
                        .u16 => "write_u16",
                        .u32 => "write_u32",
                        .u64 => "write_u64",
                        .i8 => "write_i8",
                        .i16 => "write_i16",
                        .i32 => "write_i32",
                        .i64 => "write_i64",
                        else => unreachable,
                    };
                    try self.writer.print("w.{s}({s}{s})", .{ fn_name, deref, access });
                },
            }
        },
        .float => |f| {
            const deref = if (is_ref) "*" else "";
            const fn_name = switch (f.kind) {
                .f16 => "write_f16",
                .f32 => "write_f32",
                .f64 => "write_f64",
            };
            try self.writer.print("w.{s}({s}{s})", .{ fn_name, deref, access });
        },
        .option => |o| {
            if (is_ref) {
                try self.writer.print("match {s} {{\n", .{access});
            } else {
                try self.writer.print("match &{s} {{\n", .{access});
            }
            if (isCopyType(o.child)) {
                const vn = try std.fmt.allocPrint(self.arena, "_v{d}", .{self.loop_depth});
                self.loop_depth += 1;
                try self.writer.print("        Some({s}) => {{ w.write_tag_header(1); ", .{vn});
                try self.emitEncodeExpr(o.child, vn, true);
                try self.writer.writeAll("; }\n");
                self.loop_depth -= 1;
            } else {
                const vn = try std.fmt.allocPrint(self.arena, "_v{d}", .{self.loop_depth});
                self.loop_depth += 1;
                try self.writer.print("        Some({s}) => {{ w.write_tag_header(1); ", .{vn});
                try self.emitEncodeExpr(o.child, vn, true);
                try self.writer.writeAll("; }\n");
                self.loop_depth -= 1;
            }
            try self.writer.writeAll("        None => w.write_byte(0x00),\n    }");
        },
        .array => |a| {
            if (isU8Array(a.getElement())) {
                if (is_ref) {
                    try self.writer.print("w.write_bytes({s})", .{access});
                } else {
                    try self.writer.print("w.write_bytes(&{s})", .{access});
                }
            } else {
                const lv = try std.fmt.allocPrint(self.arena, "_item{d}", .{self.loop_depth});
                self.loop_depth += 1;
                defer self.loop_depth -= 1;
                switch (a.*) {
                    .variable => |v| {
                        if (is_ref) {
                            try self.writer.print("w.write_array_header({s}.len());\n    for {s} in {s} {{ ", .{ access, lv, access });
                        } else {
                            try self.writer.print("w.write_array_header({s}.len());\n    for {s} in &{s} {{ ", .{ access, lv, access });
                        }
                        try self.emitEncodeExpr(v.element, lv, true);
                        try self.writer.writeAll("; }");
                    },
                    .fixed => |f| {
                        try self.writer.print("w.write_array_header({d});\n    for {s} in ", .{ f.len, lv });
                        if (is_ref) {
                            try self.writer.print("{s}", .{access});
                        } else {
                            try self.writer.print("&{s}", .{access});
                        }
                        try self.writer.writeAll(" { ");
                        try self.emitEncodeExpr(f.element, lv, true);
                        try self.writer.writeAll("; }");
                    },
                    .external_len => |e| {
                        try self.writer.writeAll("w.write_byte(0x9f);\n    for ");
                        try self.writer.print("{s} in ", .{lv});
                        if (is_ref) {
                            try self.writer.print("{s}", .{access});
                        } else {
                            try self.writer.print("&{s}", .{access});
                        }
                        try self.writer.writeAll(" { ");
                        try self.emitEncodeExpr(e.element, lv, true);
                        try self.writer.writeAll("; }\n    w.write_byte(0xff)");
                    },
                }
            }
        },
        .struct_ => |s| {
            if (self.inline_struct_names.get(s)) |sname| {
                const sfn = try toSnakeCaseAlloc(self.arena, sname);
                if (is_ref) {
                    try self.writer.print("_enc_{s}(w, {s})", .{ sfn, access });
                } else {
                    try self.writer.print("_enc_{s}(w, &{s})", .{ sfn, access });
                }
            }
        },
        .enum_ => |e| {
            if (self.inline_enum_names.get(e)) |ename| {
                const efn = try toSnakeCaseAlloc(self.arena, ename);
                if (is_ref) {
                    try self.writer.print("_enc_{s}(w, {s})", .{ efn, access });
                } else {
                    try self.writer.print("_enc_{s}(w, &{s})", .{ efn, access });
                }
            }
        },
        .union_ => |u| {
            if (self.inline_union_names.get(u)) |uname| {
                const ufn = try toSnakeCaseAlloc(self.arena, uname);
                if (is_ref) {
                    try self.writer.print("_enc_{s}(w, {s})", .{ ufn, access });
                } else {
                    try self.writer.print("_enc_{s}(w, &{s})", .{ ufn, access });
                }
            }
        },
        .named => |n| {
            const nfn = try toSnakeCaseAlloc(self.arena, n.name);
            if (is_ref) {
                try self.writer.print("_enc_{s}(w, {s})", .{ nfn, access });
            } else {
                try self.writer.print("_enc_{s}(w, &{s})", .{ nfn, access });
            }
        },
        .qualified => |q| {
            if (self.resolveQualified(q.namespace, q.name)) |_| {
                const qfn = try toSnakeCaseAlloc(self.arena, q.name);
                if (is_ref) {
                    try self.writer.print("_enc_{s}(w, {s})", .{ qfn, access });
                } else {
                    try self.writer.print("_enc_{s}(w, &{s})", .{ qfn, access });
                }
            }
        },
    }
}

// =========================================================================
// Decoders
// =========================================================================

fn emitDecoderForDef(self: *RsGen, def: Ast.TypeDef) Error!void {
    switch (def.ty) {
        .struct_ => |s| try self.emitStructDecoder(def.name, s),
        .enum_ => |e| try self.emitEnumDecoder(def.name, e),
        .union_ => |u| try self.emitUnionDecoder(def.name, u),
        else => {
            // Type alias
            const fn_name = try toSnakeCaseAlloc(self.arena, def.name);
            try self.writer.print("\nfn _dec_{s}(r: &mut Reader) -> {s} {{\n    ", .{ fn_name, def.name });
            try self.emitDecodeExpr(def.ty);
            try self.writer.writeAll("\n}\n");
            try self.writer.print("\npub fn decode_{s}(data: &[u8]) -> {s} {{\n", .{ fn_name, def.name });
            try self.writer.print("    let mut r = Reader::new(data);\n    _dec_{s}(&mut r)\n}}\n", .{fn_name});
        },
    }
}

fn emitStructDecoder(self: *RsGen, name: []const u8, def: *const Ast.StructDef) Error!void {
    const fn_name = try toSnakeCaseAlloc(self.arena, name);
    try self.writer.print("\nfn _dec_{s}(r: &mut Reader) -> {s} {{\n", .{ fn_name, name });
    try self.writer.writeAll("    let _len = r.read_array_header();\n");

    if (def.fields.len == 0) {
        try self.writer.writeAll("    for _ in 0.._len { r.skip(); }\n");
        try self.writer.print("    {s} {{}}\n}}\n", .{name});
    } else {
        const max_rank = maxRank(def);

        // Declare mutable locals with defaults
        for (def.fields) |field| {
            const fname = try self.toSnakeCase(field.name);
            const safe_name = try rustSafeIdent(self.arena, fname);
            try self.writer.print("    let mut _{s}: ", .{safe_name});
            try self.emitTypeRef(field.ty);
            if (field.ty == .option) {
                try self.writer.writeAll(" = None;\n");
            } else {
                try self.writer.writeAll(" = ");
                try self.emitDefaultValue(field.ty);
                try self.writer.writeAll(";\n");
            }
        }

        // Read fields by rank
        var rank: u64 = 0;
        while (rank <= max_rank) : (rank += 1) {
            try self.writer.print("    if _len > {d} {{ ", .{rank});
            if (findFieldByRank(def, rank)) |field| {
                const fname = try self.toSnakeCase(field.name);
                const safe_name = try rustSafeIdent(self.arena, fname);
                try self.writer.print("_{s} = ", .{safe_name});
                try self.emitDecodeExpr(field.ty);
                try self.writer.writeAll("; }\n");
            } else {
                try self.writer.writeAll("r.skip(); }\n");
            }
        }

        // Skip extra fields
        try self.writer.print("    for _ in {d}.._len {{ r.skip(); }}\n", .{max_rank + 1});

        // Construct result
        try self.writer.print("    {s} {{\n", .{name});
        for (def.fields) |field| {
            const fname = try self.toSnakeCase(field.name);
            const safe_name = try rustSafeIdent(self.arena, fname);
            try self.writer.print("        {s}: _{s},\n", .{ safe_name, safe_name });
        }
        try self.writer.writeAll("    }\n}\n");
    }
}

fn emitEnumDecoder(self: *RsGen, name: []const u8, def: *const Ast.EnumDef) Error!void {
    const fn_name = try toSnakeCaseAlloc(self.arena, name);
    try self.writer.print("\nfn _dec_{s}(r: &mut Reader) -> {s} {{\n", .{ fn_name, name });
    try self.writer.writeAll("    match r.read_uvarint() {\n");
    for (def.variants) |v| {
        const vname = try toPascalCase(self.arena, v.name);
        try self.writer.print("        {d} => {s}::{s},\n", .{ v.tag, name, vname });
    }
    try self.writer.print("        t => panic!(\"unknown {s} tag {{t}}\"),\n", .{name});
    try self.writer.writeAll("    }\n}\n");
}

fn emitUnionDecoder(self: *RsGen, name: []const u8, def: *const Ast.UnionDef) Error!void {
    const fn_name = try toSnakeCaseAlloc(self.arena, name);
    try self.writer.print("\nfn _dec_{s}(r: &mut Reader) -> {s} {{\n", .{ fn_name, name });
    try self.writer.writeAll("    let _b = r.peek_byte();\n");
    try self.writer.writeAll("    let _maj = _b >> 5;\n");
    try self.writer.writeAll("    if _maj == 6 {\n");
    try self.writer.writeAll("        let _b = r.read_byte();\n");
    try self.writer.writeAll("        let _ai = _b & 0x1f;\n");
    try self.writer.writeAll("        let _tag: u64 = match _ai {\n");
    try self.writer.writeAll("            0..=23 => _ai as u64,\n");
    try self.writer.writeAll("            24 => r.read_byte() as u64,\n");
    try self.writer.writeAll("            25 => { let b = [r.read_byte(), r.read_byte()]; u16::from_be_bytes(b) as u64 }\n");
    try self.writer.writeAll("            26 => { let b = [r.read_byte(), r.read_byte(), r.read_byte(), r.read_byte()]; u32::from_be_bytes(b) as u64 }\n");
    try self.writer.writeAll("            _ => panic!(\"unsupported tag size\"),\n");
    try self.writer.writeAll("        };\n");
    try self.writer.writeAll("        match _tag {\n");
    for (def.variants) |v| {
        if (v.payload) |payload| {
            const vname = try toPascalCase(self.arena, v.name);
            try self.writer.print("            {d} => {s}::{s}(", .{ v.tag, name, vname });
            try self.emitDecodeExpr(payload);
            try self.writer.writeAll("),\n");
        }
    }
    try self.writer.print("            _ => panic!(\"unknown {s} tag {{_tag}}\"),\n", .{name});
    try self.writer.writeAll("        }\n");
    try self.writer.writeAll("    } else if _maj == 0 {\n");
    try self.writer.writeAll("        let _tag = r.read_uvarint();\n");
    try self.writer.writeAll("        match _tag {\n");
    for (def.variants) |v| {
        if (v.payload == null) {
            const vname = try toPascalCase(self.arena, v.name);
            try self.writer.print("            {d} => {s}::{s},\n", .{ v.tag, name, vname });
        }
    }
    try self.writer.print("            _ => panic!(\"unknown {s} tag {{_tag}}\"),\n", .{name});
    try self.writer.writeAll("        }\n");
    try self.writer.print("    }} else {{\n        panic!(\"expected union {s}\")\n    }}\n}}\n", .{name});
}

fn emitDecodeExpr(self: *RsGen, ty: Ast.TypeExpr) Error!void {
    switch (ty) {
        .bool => try self.writer.writeAll("r.read_bool()"),
        .string => try self.writer.writeAll("r.read_string()"),
        .int => |i| {
            const fn_name = switch (i.kind) {
                .u8 => "r.read_u8()",
                .u16 => "r.read_u16()",
                .u32 => "r.read_u32()",
                .u64 => "r.read_u64()",
                .i8 => "r.read_i8()",
                .i16 => "r.read_i16()",
                .i32 => "r.read_i32()",
                .i64 => "r.read_i64()",
                .uvar => "r.read_uvarint()",
                .ivar => "r.read_ivarint()",
            };
            try self.writer.writeAll(fn_name);
        },
        .float => |f| {
            const fn_name = switch (f.kind) {
                .f16 => "r.read_f16()",
                .f32 => "r.read_f32()",
                .f64 => "r.read_f64()",
            };
            try self.writer.writeAll(fn_name);
        },
        .option => |o| {
            try self.writer.writeAll("if r.peek_byte() == 0x00 { r.read_byte(); None } else { r.read_byte(); Some(");
            try self.emitDecodeExpr(o.child);
            try self.writer.writeAll(") }");
        },
        .array => |a| {
            if (isU8Array(a.getElement())) {
                try self.writer.writeAll("r.read_bytes()");
            } else switch (a.*) {
                .variable => |v| {
                    try self.writer.writeAll("{ let _n = r.read_array_header(); (0.._n).map(|_| ");
                    try self.emitDecodeExpr(v.element);
                    try self.writer.writeAll(").collect() }");
                },
                .fixed => |f| {
                    try self.writer.print("{{ let _ = r.read_array_header(); (0..{d}).map(|_| ", .{f.len});
                    try self.emitDecodeExpr(f.element);
                    try self.writer.writeAll(").collect() }");
                },
                .external_len => |e| {
                    try self.writer.writeAll("{ assert_eq!(r.read_byte(), 0x9f, \"expected indefinite array\"); let mut _a = Vec::new(); while r.peek_byte() != 0xff { _a.push(");
                    try self.emitDecodeExpr(e.element);
                    try self.writer.writeAll("); } r.read_byte(); _a }");
                },
            }
        },
        .struct_ => |s| {
            if (self.inline_struct_names.get(s)) |sname| {
                const sfn = try toSnakeCaseAlloc(self.arena, sname);
                try self.writer.print("_dec_{s}(r)", .{sfn});
            }
        },
        .enum_ => |e| {
            if (self.inline_enum_names.get(e)) |ename| {
                const efn = try toSnakeCaseAlloc(self.arena, ename);
                try self.writer.print("_dec_{s}(r)", .{efn});
            }
        },
        .union_ => |u| {
            if (self.inline_union_names.get(u)) |uname| {
                const ufn = try toSnakeCaseAlloc(self.arena, uname);
                try self.writer.print("_dec_{s}(r)", .{ufn});
            }
        },
        .named => |n| {
            const nfn = try toSnakeCaseAlloc(self.arena, n.name);
            try self.writer.print("_dec_{s}(r)", .{nfn});
        },
        .qualified => |q| {
            if (self.resolveQualified(q.namespace, q.name)) |_| {
                const qfn = try toSnakeCaseAlloc(self.arena, q.name);
                try self.writer.print("_dec_{s}(r)", .{qfn});
            } else {
                try self.writer.print("panic!(\"unresolved {s}.{s}\")", .{ q.namespace, q.name });
            }
        },
    }
}

fn emitDefaultValue(self: *RsGen, ty: Ast.TypeExpr) Error!void {
    switch (ty) {
        .bool => try self.writer.writeAll("false"),
        .string => try self.writer.writeAll("String::new()"),
        .int => try self.writer.writeAll("0"),
        .float => try self.writer.writeAll("0.0"),
        .option => try self.writer.writeAll("None"),
        .array => try self.writer.writeAll("Vec::new()"),
        .struct_ => |s| {
            if (self.inline_struct_names.get(s)) |sname| {
                try self.writer.print("{s} {{ ", .{sname});
                for (s.fields, 0..) |field, idx| {
                    const fname = try self.toSnakeCase(field.name);
                    const safe_name = try rustSafeIdent(self.arena, fname);
                    try self.writer.print("{s}: ", .{safe_name});
                    try self.emitDefaultValue(field.ty);
                    if (idx < s.fields.len - 1) try self.writer.writeAll(", ");
                }
                try self.writer.writeAll(" }");
            } else {
                try self.writer.writeAll("Default::default()");
            }
        },
        .enum_ => |e| {
            if (self.inline_enum_names.get(e)) |ename| {
                if (e.variants.len > 0) {
                    const vname = try toPascalCase(self.arena, e.variants[0].name);
                    try self.writer.print("{s}::{s}", .{ ename, vname });
                } else {
                    try self.writer.writeAll("Default::default()");
                }
            } else {
                try self.writer.writeAll("Default::default()");
            }
        },
        .union_ => |u| {
            if (self.inline_union_names.get(u)) |uname| {
                if (u.variants.len > 0) {
                    const v = u.variants[0];
                    const vname = try toPascalCase(self.arena, v.name);
                    if (v.payload != null) {
                        try self.writer.print("{s}::{s}(Default::default())", .{ uname, vname });
                    } else {
                        try self.writer.print("{s}::{s}", .{ uname, vname });
                    }
                }
            } else {
                try self.writer.writeAll("Default::default()");
            }
        },
        .named => |n| {
            try self.emitDefaultForNamedType(n.name);
        },
        .qualified => |q| {
            if (self.resolveQualified(q.namespace, q.name)) |resolved| {
                try self.emitDefaultForTypeDef(q.name, resolved);
            } else {
                try self.writer.writeAll("unsafe { std::mem::zeroed() }");
            }
        },
    }
}

// =========================================================================
// Impl blocks
// =========================================================================

fn emitImplBlock(self: *RsGen, name: []const u8) Error!void {
    const fn_name = try toSnakeCaseAlloc(self.arena, name);
    try self.writer.print("\nimpl {s} {{\n", .{name});
    try self.writer.writeAll("    pub fn encode(&self) -> Vec<u8> {\n");
    try self.writer.writeAll("        let mut w = Writer::new();\n");
    try self.writer.print("        _enc_{s}(&mut w, self);\n", .{fn_name});
    try self.writer.writeAll("        w.finish()\n");
    try self.writer.writeAll("    }\n\n");
    try self.writer.writeAll("    pub fn encode_with(&self, w: &mut Writer) {\n");
    try self.writer.print("        _enc_{s}(w, self);\n", .{fn_name});
    try self.writer.writeAll("    }\n\n");
    try self.writer.print("    pub fn decode(data: &[u8]) -> Self {{\n", .{});
    try self.writer.writeAll("        let mut r = Reader::new(data);\n");
    try self.writer.print("        _dec_{s}(&mut r)\n", .{fn_name});
    try self.writer.writeAll("    }\n\n");
    try self.writer.print("    pub fn decode_with(r: &mut Reader) -> Self {{\n", .{});
    try self.writer.print("        _dec_{s}(r)\n", .{fn_name});
    try self.writer.writeAll("    }\n");
    try self.writer.writeAll("}\n");
}

// =========================================================================
// Helpers
// =========================================================================

fn maxRank(def: *const Ast.StructDef) u64 {
    var max: u64 = 0;
    for (def.fields) |field| {
        if (field.rank > max) max = field.rank;
    }
    return if (def.fields.len == 0) 0 else max;
}

fn findFieldByRank(def: *const Ast.StructDef, rank: u64) ?Ast.FieldDef {
    for (def.fields) |field| {
        if (field.rank == rank) return field;
    }
    return null;
}

fn sanitizeFieldName(self: *RsGen, name: []const u8) Error![]const u8 {
    if (name.len > 0 and std.ascii.isDigit(name[0])) {
        return try std.fmt.allocPrint(self.arena, "_{s}", .{name});
    }
    return name;
}

/// Convert a name to snake_case for Rust field/function names.
fn toSnakeCase(self: *RsGen, name: []const u8) Error![]const u8 {
    return toSnakeCaseAlloc(self.arena, name);
}

/// Check if a type expression is `u8` (for byte array special-casing).
fn isU8Array(element: Ast.TypeExpr) bool {
    return element == .int and element.int.kind == .u8;
}

/// Look up a named type in the main schema or imported schemas.
fn resolveNamedTypeDef(self: *RsGen, name: []const u8) ?Ast.TypeDef {
    for (self.schema.definitions) |def| {
        if (std.mem.eql(u8, def.name, name)) return def;
    }
    var import_it = self.imports.iterator();
    while (import_it.next()) |entry| {
        for (entry.value_ptr.definitions) |def| {
            if (std.mem.eql(u8, def.name, name)) return def;
        }
    }
    return null;
}

/// Emit a default value for a named type reference.
fn emitDefaultForNamedType(self: *RsGen, name: []const u8) Error!void {
    if (self.resolveNamedTypeDef(name)) |def| {
        try self.emitDefaultForTypeDef(name, def);
    } else {
        try self.writer.writeAll("unsafe { std::mem::zeroed() }");
    }
}

/// Emit a default value given a type name and its definition.
fn emitDefaultForTypeDef(self: *RsGen, name: []const u8, def: Ast.TypeDef) Error!void {
    switch (def.ty) {
        .enum_ => |e| {
            if (e.variants.len > 0) {
                const vname = try toPascalCase(self.arena, e.variants[0].name);
                try self.writer.print("{s}::{s}", .{ name, vname });
            } else {
                try self.writer.writeAll("unsafe { std::mem::zeroed() }");
            }
        },
        .union_ => |u| {
            if (u.variants.len > 0) {
                const v = u.variants[0];
                const vname = try toPascalCase(self.arena, v.name);
                if (v.payload != null) {
                    try self.writer.print("{s}::{s}(Default::default())", .{ name, vname });
                } else {
                    try self.writer.print("{s}::{s}", .{ name, vname });
                }
            } else {
                try self.writer.writeAll("unsafe { std::mem::zeroed() }");
            }
        },
        .struct_ => |s| {
            try self.writer.print("{s} {{ ", .{name});
            for (s.fields, 0..) |field, idx| {
                const fname = try self.toSnakeCase(field.name);
                const safe_name = try rustSafeIdent(self.arena, fname);
                try self.writer.print("{s}: ", .{safe_name});
                try self.emitDefaultValue(field.ty);
                if (idx < s.fields.len - 1) try self.writer.writeAll(", ");
            }
            try self.writer.writeAll(" }");
        },
        else => {
            // Alias to a primitive type — delegate
            try self.emitDefaultValue(def.ty);
        },
    }
}

/// Look up a qualified type reference in imported schemas.
fn resolveQualified(self: *RsGen, namespace: []const u8, name: []const u8) ?Ast.TypeDef {
    const imported_schema = self.imports.get(namespace) orelse return null;
    for (imported_schema.definitions) |def| {
        if (std.mem.eql(u8, def.name, name)) return def;
    }
    return null;
}

/// Check if a type is Copy in Rust (primitives and enums).
fn isCopyType(ty: Ast.TypeExpr) bool {
    return switch (ty) {
        .bool, .int, .float => true,
        .enum_ => true,
        else => false,
    };
}

// =========================================================================
// Name conversion utilities
// =========================================================================

/// Convert PascalCase/camelCase to snake_case. Allocates on the given arena.
fn toSnakeCaseAlloc(arena: std.mem.Allocator, name: []const u8) Error![]const u8 {
    if (name.len == 0) return name;

    var result: std.ArrayList(u8) = .{};

    for (name, 0..) |c, i| {
        if (c == '_') {
            try result.append(arena, '_');
            continue;
        }
        if (std.ascii.isUpper(c)) {
            // Insert underscore before uppercase if:
            // - Not at the start
            // - Previous char is not uppercase or underscore
            // - OR previous is uppercase but next is lowercase (e.g., "XMLParser" → "xml_parser")
            if (i > 0 and name[i - 1] != '_') {
                const prev_upper = std.ascii.isUpper(name[i - 1]);
                if (!prev_upper) {
                    try result.append(arena, '_');
                } else if (i + 1 < name.len and std.ascii.isLower(name[i + 1])) {
                    try result.append(arena, '_');
                }
            }
            try result.append(arena, std.ascii.toLower(c));
        } else {
            try result.append(arena, c);
        }
    }

    return result.items;
}

/// Convert a name to PascalCase. Allocates on the given arena.
fn toPascalCase(arena: std.mem.Allocator, name: []const u8) Error![]const u8 {
    if (name.len == 0) return name;

    // If starts with digit, prefix with underscore
    if (std.ascii.isDigit(name[0])) {
        return try std.fmt.allocPrint(arena, "_{s}", .{name});
    }

    // Check if name contains underscores — if so, always process
    const has_underscores = std.mem.indexOfScalar(u8, name, '_') != null;
    if (!has_underscores and std.ascii.isUpper(name[0])) return name;

    // Capitalize first letter, convert underscores to camelCase boundaries
    var result: std.ArrayList(u8) = .{};
    try result.append(arena, std.ascii.toUpper(name[0]));

    var capitalize_next = false;
    for (name[1..]) |c| {
        if (c == '_') {
            capitalize_next = true;
            continue;
        }
        if (capitalize_next) {
            try result.append(arena, std.ascii.toUpper(c));
            capitalize_next = false;
        } else {
            try result.append(arena, c);
        }
    }

    return result.items;
}

/// Rust reserved words that need escaping with a trailing underscore.
const rust_reserved = std.StaticStringMap(void).initComptime(.{
    .{ "as", {} },
    .{ "break", {} },
    .{ "const", {} },
    .{ "continue", {} },
    .{ "crate", {} },
    .{ "else", {} },
    .{ "enum", {} },
    .{ "extern", {} },
    .{ "false", {} },
    .{ "fn", {} },
    .{ "for", {} },
    .{ "if", {} },
    .{ "impl", {} },
    .{ "in", {} },
    .{ "let", {} },
    .{ "loop", {} },
    .{ "match", {} },
    .{ "mod", {} },
    .{ "move", {} },
    .{ "mut", {} },
    .{ "pub", {} },
    .{ "ref", {} },
    .{ "return", {} },
    .{ "self", {} },
    .{ "Self", {} },
    .{ "static", {} },
    .{ "struct", {} },
    .{ "super", {} },
    .{ "trait", {} },
    .{ "true", {} },
    .{ "type", {} },
    .{ "unsafe", {} },
    .{ "use", {} },
    .{ "where", {} },
    .{ "while", {} },
    .{ "async", {} },
    .{ "await", {} },
    .{ "dyn", {} },
    .{ "abstract", {} },
    .{ "become", {} },
    .{ "box", {} },
    .{ "do", {} },
    .{ "final", {} },
    .{ "macro", {} },
    .{ "override", {} },
    .{ "priv", {} },
    .{ "typeof", {} },
    .{ "unsized", {} },
    .{ "virtual", {} },
    .{ "yield", {} },
    .{ "try", {} },
    .{ "str", {} },
    .{ "i8", {} },
    .{ "i16", {} },
    .{ "i32", {} },
    .{ "i64", {} },
    .{ "u8", {} },
    .{ "u16", {} },
    .{ "u32", {} },
    .{ "u64", {} },
    .{ "f32", {} },
    .{ "f64", {} },
    .{ "bool", {} },
    .{ "char", {} },
    .{ "usize", {} },
    .{ "isize", {} },
});

/// Make an identifier safe for Rust — append underscore if reserved.
fn rustSafeIdent(arena: std.mem.Allocator, name: []const u8) Error![]const u8 {
    if (name.len > 0 and std.ascii.isDigit(name[0])) {
        return try std.fmt.allocPrint(arena, "_{s}", .{name});
    }
    if (rust_reserved.has(name)) {
        return try std.fmt.allocPrint(arena, "{s}_", .{name});
    }
    return name;
}
