// Generated by cboragen â€” do not edit

use cboragen_runtime::{Writer, Reader, DecodeError};

// === Types ===

#[derive(Debug, Clone, PartialEq, Default)]
pub struct ShapeRect {
    pub w: f64,
    pub h: f64,
}
/// All primitive types in one struct

#[derive(Debug, Clone, PartialEq, Default)]
pub struct Primitives {
    pub b: bool,
    pub u8v: u8,
    pub u16v: u16,
    pub u32v: u32,
    pub u64v: u64,
    pub i8v: i8,
    pub i16v: i16,
    pub i32v: i32,
    pub i64v: i64,
    pub f32v: f32,
    pub f64v: f64,
    pub uvar: u64,
    pub ivar: i64,
    pub str_: String,
    pub bin: Vec<u8>,
}
/// Struct with optional fields

#[derive(Debug, Clone, PartialEq, Default)]
pub struct WithOptionals {
    pub required: String,
    pub maybe: Option<u32>,
    pub maybe_str: Option<String>,
}
/// Simple enum

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Color {
    Red,
    Green,
    Blue,
}
/// Union with unit and payload variants

#[derive(Debug, Clone, PartialEq)]
pub enum Shape {
    Circle(f64),
    Rect(ShapeRect),
    Point,
}
/// Variable-length array wrapper

#[derive(Debug, Clone, PartialEq, Default)]
pub struct Numbers {
    pub values: Vec<i32>,
}
/// Fixed-length array wrapper

#[derive(Debug, Clone, PartialEq, Default)]
pub struct Vec3 {
    pub xyz: Vec<f64>,
}
/// External-length array wrapper

#[derive(Debug, Clone, PartialEq, Default)]
pub struct TimeSeries {
    pub count: u32,
    pub timestamps: Vec<i64>,
    pub values: Vec<f64>,
}
/// Named type references

#[derive(Debug, Clone, PartialEq)]
pub struct ColoredShape {
    pub color: Color,
    pub shape: Shape,
}
/// Type alias

pub type Id = u64;
/// Struct referencing an alias

#[derive(Debug, Clone, PartialEq, Default)]
pub struct Entity {
    pub id: Id,
    pub name: String,
}
/// Nested arrays

#[derive(Debug, Clone, PartialEq, Default)]
pub struct Matrix {
    pub rows: Vec<Vec<f64>>,
}
/// Struct with gaps in ranks

#[derive(Debug, Clone, PartialEq, Default)]
pub struct Sparse {
    pub first: u32,
    pub second: String,
    pub third: bool,
}

// === Encoders ===

fn _enc_shape_rect(w: &mut Writer, v: &ShapeRect) {
    w.write_array_header(2);
    w.write_f64(v.w);
    w.write_f64(v.h);
}

fn _enc_primitives(w: &mut Writer, v: &Primitives) {
    w.write_array_header(15);
    w.write_bool(v.b);
    w.write_u8(v.u8v);
    w.write_u16(v.u16v);
    w.write_u32(v.u32v);
    w.write_u64(v.u64v);
    w.write_i8(v.i8v);
    w.write_i16(v.i16v);
    w.write_i32(v.i32v);
    w.write_i64(v.i64v);
    w.write_f32(v.f32v);
    w.write_f64(v.f64v);
    w.write_uvarint(v.uvar);
    w.write_ivarint(v.ivar);
    w.write_string(&v.str_);
    w.write_bytes(&v.bin);
}

fn _enc_with_optionals(w: &mut Writer, v: &WithOptionals) {
    w.write_array_header(3);
    w.write_string(&v.required);
    match &v.maybe {
        Some(_v0) => { w.write_tag_header(1); w.write_u32(*_v0); }
        None => w.write_byte(0x00),
    };
    match &v.maybe_str {
        Some(_v0) => { w.write_tag_header(1); w.write_string(_v0); }
        None => w.write_byte(0x00),
    };
}

fn _enc_color(w: &mut Writer, v: &Color) {
    match v {
        Color::Red => w.write_uvarint(0),
        Color::Green => w.write_uvarint(1),
        Color::Blue => w.write_uvarint(2),
    }
}

fn _enc_shape(w: &mut Writer, v: &Shape) {
    match v {
        Shape::Circle(val) => {
            w.write_tag_header(0);
            w.write_f64(*val);
        }
        Shape::Rect(val) => {
            w.write_tag_header(1);
            _enc_shape_rect(w, val);
        }
        Shape::Point => w.write_uvarint(2),
    }
}

fn _enc_numbers(w: &mut Writer, v: &Numbers) {
    w.write_array_header(1);
    w.write_array_header(v.values.len());
    for _item0 in &v.values { w.write_i32(*_item0); };
}

fn _enc_vec3(w: &mut Writer, v: &Vec3) {
    w.write_array_header(1);
    w.write_array_header(3);
    for _item0 in &v.xyz { w.write_f64(*_item0); };
}

fn _enc_time_series(w: &mut Writer, v: &TimeSeries) {
    w.write_array_header(3);
    w.write_u32(v.count);
    w.write_byte(0x9f);
    for _item0 in &v.timestamps { w.write_i64(*_item0); }
    w.write_byte(0xff);
    w.write_byte(0x9f);
    for _item0 in &v.values { w.write_f64(*_item0); }
    w.write_byte(0xff);
}

fn _enc_colored_shape(w: &mut Writer, v: &ColoredShape) {
    w.write_array_header(2);
    _enc_color(w, &v.color);
    _enc_shape(w, &v.shape);
}

fn _enc_id(w: &mut Writer, v: &Id) {
    w.write_u64(*v);
}

pub fn encode_id(value: &Id) -> Vec<u8> {
    let mut w = Writer::new();
    _enc_id(&mut w, value);
    w.finish()
}

fn _enc_entity(w: &mut Writer, v: &Entity) {
    w.write_array_header(2);
    _enc_id(w, &v.id);
    w.write_string(&v.name);
}

fn _enc_matrix(w: &mut Writer, v: &Matrix) {
    w.write_array_header(1);
    w.write_array_header(v.rows.len());
    for _item0 in &v.rows { w.write_array_header(_item0.len());
    for _item1 in _item0 { w.write_f64(*_item1); }; };
}

fn _enc_sparse(w: &mut Writer, v: &Sparse) {
    w.write_array_header(11);
    w.write_u32(v.first);
    w.write_null();
    w.write_null();
    w.write_null();
    w.write_null();
    w.write_string(&v.second);
    w.write_null();
    w.write_null();
    w.write_null();
    w.write_null();
    w.write_bool(v.third);
}

// === Decoders ===

fn _dec_shape_rect(r: &mut Reader) -> Result<ShapeRect, DecodeError> {
    let _len = r.read_array_header()?;
    let mut _w: f64 = 0.0;
    let mut _h: f64 = 0.0;
    if _len > 0 { _w = r.read_f64()?; }
    if _len > 1 { _h = r.read_f64()?; }
    for _ in 2.._len { r.skip()?; }
    Ok(ShapeRect {
        w: _w,
        h: _h,
    })
}

fn _dec_primitives(r: &mut Reader) -> Result<Primitives, DecodeError> {
    let _len = r.read_array_header()?;
    let mut _b: bool = false;
    let mut _u8v: u8 = 0;
    let mut _u16v: u16 = 0;
    let mut _u32v: u32 = 0;
    let mut _u64v: u64 = 0;
    let mut _i8v: i8 = 0;
    let mut _i16v: i16 = 0;
    let mut _i32v: i32 = 0;
    let mut _i64v: i64 = 0;
    let mut _f32v: f32 = 0.0;
    let mut _f64v: f64 = 0.0;
    let mut _uvar: u64 = 0;
    let mut _ivar: i64 = 0;
    let mut _str_: String = String::new();
    let mut _bin: Vec<u8> = Vec::new();
    if _len > 0 { _b = r.read_bool()?; }
    if _len > 1 { _u8v = r.read_u8()?; }
    if _len > 2 { _u16v = r.read_u16()?; }
    if _len > 3 { _u32v = r.read_u32()?; }
    if _len > 4 { _u64v = r.read_u64()?; }
    if _len > 5 { _i8v = r.read_i8()?; }
    if _len > 6 { _i16v = r.read_i16()?; }
    if _len > 7 { _i32v = r.read_i32()?; }
    if _len > 8 { _i64v = r.read_i64()?; }
    if _len > 9 { _f32v = r.read_f32()?; }
    if _len > 10 { _f64v = r.read_f64()?; }
    if _len > 11 { _uvar = r.read_uvarint()?; }
    if _len > 12 { _ivar = r.read_ivarint()?; }
    if _len > 13 { _str_ = r.read_string()?; }
    if _len > 14 { _bin = r.read_bytes()?; }
    for _ in 15.._len { r.skip()?; }
    Ok(Primitives {
        b: _b,
        u8v: _u8v,
        u16v: _u16v,
        u32v: _u32v,
        u64v: _u64v,
        i8v: _i8v,
        i16v: _i16v,
        i32v: _i32v,
        i64v: _i64v,
        f32v: _f32v,
        f64v: _f64v,
        uvar: _uvar,
        ivar: _ivar,
        str_: _str_,
        bin: _bin,
    })
}

fn _dec_with_optionals(r: &mut Reader) -> Result<WithOptionals, DecodeError> {
    let _len = r.read_array_header()?;
    let mut _required: String = String::new();
    let mut _maybe: Option<u32> = None;
    let mut _maybe_str: Option<String> = None;
    if _len > 0 { _required = r.read_string()?; }
    if _len > 1 { _maybe = if r.peek_byte()? == 0x00 { r.read_byte()?; None } else { r.read_byte()?; Some(r.read_u32()?) }; }
    if _len > 2 { _maybe_str = if r.peek_byte()? == 0x00 { r.read_byte()?; None } else { r.read_byte()?; Some(r.read_string()?) }; }
    for _ in 3.._len { r.skip()?; }
    Ok(WithOptionals {
        required: _required,
        maybe: _maybe,
        maybe_str: _maybe_str,
    })
}

fn _dec_color(r: &mut Reader) -> Result<Color, DecodeError> {
    match r.read_uvarint()? {
        0 => Ok(Color::Red),
        1 => Ok(Color::Green),
        2 => Ok(Color::Blue),
        t => Err(DecodeError::InvalidData(format!("unknown Color tag {t}"))),
    }
}

fn _dec_shape(r: &mut Reader) -> Result<Shape, DecodeError> {
    let _b = r.peek_byte()?;
    let _maj = _b >> 5;
    if _maj == 6 {
        let _b = r.read_byte()?;
        let _ai = _b & 0x1f;
        let _tag: u64 = match _ai {
            0..=23 => _ai as u64,
            24 => r.read_byte()? as u64,
            25 => { let b = [r.read_byte()?, r.read_byte()?]; u16::from_be_bytes(b) as u64 }
            26 => { let b = [r.read_byte()?, r.read_byte()?, r.read_byte()?, r.read_byte()?]; u32::from_be_bytes(b) as u64 }
            _ => return Err(DecodeError::InvalidData("unsupported tag size".into())),
        };
        match _tag {
            0 => Ok(Shape::Circle(r.read_f64()?)),
            1 => Ok(Shape::Rect(_dec_shape_rect(r)?)),
            _ => Err(DecodeError::InvalidData(format!("unknown Shape tag {_tag}"))),
        }
    } else if _maj == 0 {
        let _tag = r.read_uvarint()?;
        match _tag {
            2 => Ok(Shape::Point),
            _ => Err(DecodeError::InvalidData(format!("unknown Shape tag {_tag}"))),
        }
    } else {
        Err(DecodeError::InvalidData(format!("expected union Shape, got major type {_maj}")))
    }
}

fn _dec_numbers(r: &mut Reader) -> Result<Numbers, DecodeError> {
    let _len = r.read_array_header()?;
    let mut _values: Vec<i32> = Vec::new();
    if _len > 0 { _values = { let _n = r.read_array_header()?; let mut _a = Vec::with_capacity(_n); for _ in 0.._n { _a.push(r.read_i32()?); } _a }; }
    for _ in 1.._len { r.skip()?; }
    Ok(Numbers {
        values: _values,
    })
}

fn _dec_vec3(r: &mut Reader) -> Result<Vec3, DecodeError> {
    let _len = r.read_array_header()?;
    let mut _xyz: Vec<f64> = Vec::new();
    if _len > 0 { _xyz = { let _ = r.read_array_header()?; let mut _a = Vec::with_capacity(3); for _ in 0..3usize { _a.push(r.read_f64()?); } _a }; }
    for _ in 1.._len { r.skip()?; }
    Ok(Vec3 {
        xyz: _xyz,
    })
}

fn _dec_time_series(r: &mut Reader) -> Result<TimeSeries, DecodeError> {
    let _len = r.read_array_header()?;
    let mut _count: u32 = 0;
    let mut _timestamps: Vec<i64> = Vec::new();
    let mut _values: Vec<f64> = Vec::new();
    if _len > 0 { _count = r.read_u32()?; }
    if _len > 1 { _timestamps = { if r.read_byte()? != 0x9f { return Err(DecodeError::InvalidData("expected indefinite array".into())); } let mut _a = Vec::new(); while r.peek_byte()? != 0xff { _a.push(r.read_i64()?); } r.read_byte()?; _a }; }
    if _len > 2 { _values = { if r.read_byte()? != 0x9f { return Err(DecodeError::InvalidData("expected indefinite array".into())); } let mut _a = Vec::new(); while r.peek_byte()? != 0xff { _a.push(r.read_f64()?); } r.read_byte()?; _a }; }
    for _ in 3.._len { r.skip()?; }
    Ok(TimeSeries {
        count: _count,
        timestamps: _timestamps,
        values: _values,
    })
}

fn _dec_colored_shape(r: &mut Reader) -> Result<ColoredShape, DecodeError> {
    let _len = r.read_array_header()?;
    let mut _color: Color = Color::Red;
    let mut _shape: Shape = Shape::Circle(0.0);
    if _len > 0 { _color = _dec_color(r)?; }
    if _len > 1 { _shape = _dec_shape(r)?; }
    for _ in 2.._len { r.skip()?; }
    Ok(ColoredShape {
        color: _color,
        shape: _shape,
    })
}

fn _dec_id(r: &mut Reader) -> Result<Id, DecodeError> {
    Ok(r.read_u64()?)
}

pub fn decode_id(data: &[u8]) -> Result<Id, DecodeError> {
    let mut r = Reader::new(data);
    _dec_id(&mut r)
}

fn _dec_entity(r: &mut Reader) -> Result<Entity, DecodeError> {
    let _len = r.read_array_header()?;
    let mut _id: Id = 0;
    let mut _name: String = String::new();
    if _len > 0 { _id = _dec_id(r)?; }
    if _len > 1 { _name = r.read_string()?; }
    for _ in 2.._len { r.skip()?; }
    Ok(Entity {
        id: _id,
        name: _name,
    })
}

fn _dec_matrix(r: &mut Reader) -> Result<Matrix, DecodeError> {
    let _len = r.read_array_header()?;
    let mut _rows: Vec<Vec<f64>> = Vec::new();
    if _len > 0 { _rows = { let _n = r.read_array_header()?; let mut _a = Vec::with_capacity(_n); for _ in 0.._n { _a.push({ let _n = r.read_array_header()?; let mut _a = Vec::with_capacity(_n); for _ in 0.._n { _a.push(r.read_f64()?); } _a }); } _a }; }
    for _ in 1.._len { r.skip()?; }
    Ok(Matrix {
        rows: _rows,
    })
}

fn _dec_sparse(r: &mut Reader) -> Result<Sparse, DecodeError> {
    let _len = r.read_array_header()?;
    let mut _first: u32 = 0;
    let mut _second: String = String::new();
    let mut _third: bool = false;
    if _len > 0 { _first = r.read_u32()?; }
    if _len > 1 { r.skip()?; }
    if _len > 2 { r.skip()?; }
    if _len > 3 { r.skip()?; }
    if _len > 4 { r.skip()?; }
    if _len > 5 { _second = r.read_string()?; }
    if _len > 6 { r.skip()?; }
    if _len > 7 { r.skip()?; }
    if _len > 8 { r.skip()?; }
    if _len > 9 { r.skip()?; }
    if _len > 10 { _third = r.read_bool()?; }
    for _ in 11.._len { r.skip()?; }
    Ok(Sparse {
        first: _first,
        second: _second,
        third: _third,
    })
}

// === Impl ===

impl ShapeRect {
    pub fn encode(&self) -> Vec<u8> {
        let mut w = Writer::new();
        _enc_shape_rect(&mut w, self);
        w.finish()
    }

    pub fn encode_with(&self, w: &mut Writer) {
        _enc_shape_rect(w, self);
    }

    pub fn decode(data: &[u8]) -> Result<Self, DecodeError> {
        let mut r = Reader::new(data);
        _dec_shape_rect(&mut r)
    }

    pub fn decode_with(r: &mut Reader) -> Result<Self, DecodeError> {
        _dec_shape_rect(r)
    }
}

impl Primitives {
    pub fn encode(&self) -> Vec<u8> {
        let mut w = Writer::new();
        _enc_primitives(&mut w, self);
        w.finish()
    }

    pub fn encode_with(&self, w: &mut Writer) {
        _enc_primitives(w, self);
    }

    pub fn decode(data: &[u8]) -> Result<Self, DecodeError> {
        let mut r = Reader::new(data);
        _dec_primitives(&mut r)
    }

    pub fn decode_with(r: &mut Reader) -> Result<Self, DecodeError> {
        _dec_primitives(r)
    }
}

impl WithOptionals {
    pub fn encode(&self) -> Vec<u8> {
        let mut w = Writer::new();
        _enc_with_optionals(&mut w, self);
        w.finish()
    }

    pub fn encode_with(&self, w: &mut Writer) {
        _enc_with_optionals(w, self);
    }

    pub fn decode(data: &[u8]) -> Result<Self, DecodeError> {
        let mut r = Reader::new(data);
        _dec_with_optionals(&mut r)
    }

    pub fn decode_with(r: &mut Reader) -> Result<Self, DecodeError> {
        _dec_with_optionals(r)
    }
}

impl Color {
    pub fn encode(&self) -> Vec<u8> {
        let mut w = Writer::new();
        _enc_color(&mut w, self);
        w.finish()
    }

    pub fn encode_with(&self, w: &mut Writer) {
        _enc_color(w, self);
    }

    pub fn decode(data: &[u8]) -> Result<Self, DecodeError> {
        let mut r = Reader::new(data);
        _dec_color(&mut r)
    }

    pub fn decode_with(r: &mut Reader) -> Result<Self, DecodeError> {
        _dec_color(r)
    }
}

impl Shape {
    pub fn encode(&self) -> Vec<u8> {
        let mut w = Writer::new();
        _enc_shape(&mut w, self);
        w.finish()
    }

    pub fn encode_with(&self, w: &mut Writer) {
        _enc_shape(w, self);
    }

    pub fn decode(data: &[u8]) -> Result<Self, DecodeError> {
        let mut r = Reader::new(data);
        _dec_shape(&mut r)
    }

    pub fn decode_with(r: &mut Reader) -> Result<Self, DecodeError> {
        _dec_shape(r)
    }
}

impl Numbers {
    pub fn encode(&self) -> Vec<u8> {
        let mut w = Writer::new();
        _enc_numbers(&mut w, self);
        w.finish()
    }

    pub fn encode_with(&self, w: &mut Writer) {
        _enc_numbers(w, self);
    }

    pub fn decode(data: &[u8]) -> Result<Self, DecodeError> {
        let mut r = Reader::new(data);
        _dec_numbers(&mut r)
    }

    pub fn decode_with(r: &mut Reader) -> Result<Self, DecodeError> {
        _dec_numbers(r)
    }
}

impl Vec3 {
    pub fn encode(&self) -> Vec<u8> {
        let mut w = Writer::new();
        _enc_vec3(&mut w, self);
        w.finish()
    }

    pub fn encode_with(&self, w: &mut Writer) {
        _enc_vec3(w, self);
    }

    pub fn decode(data: &[u8]) -> Result<Self, DecodeError> {
        let mut r = Reader::new(data);
        _dec_vec3(&mut r)
    }

    pub fn decode_with(r: &mut Reader) -> Result<Self, DecodeError> {
        _dec_vec3(r)
    }
}

impl TimeSeries {
    pub fn encode(&self) -> Vec<u8> {
        let mut w = Writer::new();
        _enc_time_series(&mut w, self);
        w.finish()
    }

    pub fn encode_with(&self, w: &mut Writer) {
        _enc_time_series(w, self);
    }

    pub fn decode(data: &[u8]) -> Result<Self, DecodeError> {
        let mut r = Reader::new(data);
        _dec_time_series(&mut r)
    }

    pub fn decode_with(r: &mut Reader) -> Result<Self, DecodeError> {
        _dec_time_series(r)
    }
}

impl ColoredShape {
    pub fn encode(&self) -> Vec<u8> {
        let mut w = Writer::new();
        _enc_colored_shape(&mut w, self);
        w.finish()
    }

    pub fn encode_with(&self, w: &mut Writer) {
        _enc_colored_shape(w, self);
    }

    pub fn decode(data: &[u8]) -> Result<Self, DecodeError> {
        let mut r = Reader::new(data);
        _dec_colored_shape(&mut r)
    }

    pub fn decode_with(r: &mut Reader) -> Result<Self, DecodeError> {
        _dec_colored_shape(r)
    }
}

impl Entity {
    pub fn encode(&self) -> Vec<u8> {
        let mut w = Writer::new();
        _enc_entity(&mut w, self);
        w.finish()
    }

    pub fn encode_with(&self, w: &mut Writer) {
        _enc_entity(w, self);
    }

    pub fn decode(data: &[u8]) -> Result<Self, DecodeError> {
        let mut r = Reader::new(data);
        _dec_entity(&mut r)
    }

    pub fn decode_with(r: &mut Reader) -> Result<Self, DecodeError> {
        _dec_entity(r)
    }
}

impl Matrix {
    pub fn encode(&self) -> Vec<u8> {
        let mut w = Writer::new();
        _enc_matrix(&mut w, self);
        w.finish()
    }

    pub fn encode_with(&self, w: &mut Writer) {
        _enc_matrix(w, self);
    }

    pub fn decode(data: &[u8]) -> Result<Self, DecodeError> {
        let mut r = Reader::new(data);
        _dec_matrix(&mut r)
    }

    pub fn decode_with(r: &mut Reader) -> Result<Self, DecodeError> {
        _dec_matrix(r)
    }
}

impl Sparse {
    pub fn encode(&self) -> Vec<u8> {
        let mut w = Writer::new();
        _enc_sparse(&mut w, self);
        w.finish()
    }

    pub fn encode_with(&self, w: &mut Writer) {
        _enc_sparse(w, self);
    }

    pub fn decode(data: &[u8]) -> Result<Self, DecodeError> {
        let mut r = Reader::new(data);
        _dec_sparse(&mut r)
    }

    pub fn decode_with(r: &mut Reader) -> Result<Self, DecodeError> {
        _dec_sparse(r)
    }
}
